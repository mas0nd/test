<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üïµÔ∏è Internal Network Reconnaissance Tool</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            border: 2px solid #00ff00;
            padding: 20px;
            border-radius: 8px;
        }
        
        .section {
            background: #1a1a1a;
            border: 2px solid #333;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
        }
        
        .critical { border-color: #ff0000; }
        .warning { border-color: #ffaa00; }
        .success { border-color: #00ff00; }
        
        .input-section {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        input[type="text"], textarea {
            background: #1a1a1a;
            border: 2px solid #333;
            color: #00ff00;
            padding: 10px;
            font-family: inherit;
            border-radius: 3px;
            width: 100%;
            box-sizing: border-box;
            margin: 5px 0;
        }
        
        textarea {
            height: 120px;
            resize: vertical;
        }
        
        button {
            background: #2d5a27;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 12px 20px;
            margin: 8px 5px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            border-radius: 5px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #00ff00;
            color: #000;
        }
        
        .critical-btn {
            background: #5a1a1a;
            border-color: #ff0000;
            color: #ff6b6b;
        }
        
        .critical-btn:hover {
            background: #ff0000;
            color: #fff;
        }
        
        .output {
            background: #000;
            border: 1px solid #333;
            padding: 15px;
            margin: 10px 0;
            min-height: 150px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 12px;
            border-radius: 3px;
        }
        
        .success { color: #00ff00; }
        .error { color: #ff6b6b; }
        .warning { color: #ffaa00; }
        .info { color: #4dabf7; }
        .critical { color: #ff0000; font-weight: bold; }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }
        
        .target-item {
            background: #2a2a2a;
            border: 1px solid #444;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .target-links {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .target-links a {
            color: #4dabf7;
            text-decoration: none;
            padding: 3px 8px;
            border: 1px solid #4dabf7;
            border-radius: 3px;
            font-size: 11px;
        }
        
        .target-links a:hover {
            background: #4dabf7;
            color: #000;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-unknown { background: #666; }
        .status-success { background: #00ff00; }
        .status-error { background: #ff6b6b; }
        .status-warning { background: #ffaa00; }
        
        .progress-bar {
            background: #333;
            border-radius: 10px;
            height: 20px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #00ff00, #4dabf7);
            height: 100%;
            width: 0%;
            transition: width 0.3s;
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #00ff00;
        }
        
        .stat-label {
            font-size: 12px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üïµÔ∏è Internal Network Reconnaissance Tool</h1>
            <p>Dynamic target testing for internal network discovery and access validation</p>
            <div class="stats" id="stats">
                <div class="stat-item">
                    <div class="stat-number" id="total-targets">0</div>
                    <div class="stat-label">Targets</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="accessible-targets">0</div>
                    <div class="stat-label">Accessible</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="tests-run">0</div>
                    <div class="stat-label">Tests Run</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="success-rate">0%</div>
                    <div class="stat-label">Success Rate</div>
                </div>
            </div>
        </div>

        <!-- Target Input Section -->
        <div class="section critical">
            <h2>üéØ Target Configuration</h2>
            <div class="input-section">
                <label>Single Target:</label>
                <input type="text" id="single-target" placeholder="192.168.1.100 or internal.company.com or 10.0.0.50:8080">
                <button onclick="addSingleTarget()">Add Target</button>
                <button onclick="addCommonPorts()">Add with Common Ports</button>
            </div>
            
            <div class="input-section">
                <label>Bulk Targets (one per line):</label>
                <textarea id="bulk-targets" placeholder="192.168.1.100&#10;internal.company.com&#10;10.0.0.50:8080&#10;172.16.10.5:443&#10;app-server.internal:9000"></textarea>
                <button onclick="addBulkTargets()">Add Bulk Targets</button>
                <button onclick="generateIPRange()">Generate IP Range</button>
            </div>

            <div class="input-section">
                <label>IP Range Generator:</label>
                <input type="text" id="ip-range" placeholder="192.168.1.1-254" style="width: 48%; display: inline-block;">
                <input type="text" id="port-list" placeholder="80,443,8080,9000" style="width: 48%; display: inline-block; margin-left: 2%;">
                <button onclick="generateRangeTargets()">Generate Range</button>
            </div>
        </div>

        <!-- Target Management -->
        <div class="section">
            <h2>üìã Target Management</h2>
            <div class="target-controls">
                <button onclick="clearAllTargets()">Clear All</button>
                <button onclick="exportTargets()">Export Results</button>
                <button onclick="importTargets()">Import Targets</button>
                <button class="critical-btn" onclick="runAllTests()">üöÄ RUN ALL TESTS</button>
            </div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            
            <div id="target-list"></div>
        </div>

        <div class="grid">
            <!-- Connectivity Testing -->
            <div class="section">
                <h2>üåê Connectivity Testing</h2>
                <button onclick="testBasicConnectivity()">Basic Connectivity</button>
                <button onclick="testProtocolAccess()">Protocol Testing</button>
                <button onclick="testPortScanning()">Port Scanning</button>
                <button onclick="testResponseTiming()">Response Timing</button>
                <div id="connectivity-output" class="output"></div>
            </div>

            <!-- HTTP/HTTPS Testing -->
            <div class="section">
                <h2>üîê HTTP/HTTPS Testing</h2>
                <button onclick="testHTTPAccess()">HTTP Access</button>
                <button onclick="testHTTPSAccess()">HTTPS Access</button>
                <button onclick="testHTTPMethods()">HTTP Methods</button>
                <button onclick="testAuthenticationEndpoints()">Auth Endpoints</button>
                <div id="http-output" class="output"></div>
            </div>

            <!-- Service Discovery -->
            <div class="section">
                <h2>üîç Service Discovery</h2>
                <button onclick="discoverServices()">Service Detection</button>
                <button onclick="testCommonEndpoints()">Common Endpoints</button>
                <button onclick="testAPIEndpoints()">API Discovery</button>
                <button onclick="testAdminPanels()">Admin Panels</button>
                <div id="discovery-output" class="output"></div>
            </div>

            <!-- Advanced Testing -->
            <div class="section warning">
                <h2>‚ö° Advanced Testing</h2>
                <button onclick="testWebSocketConnections()">WebSocket Testing</button>
                <button onclick="testCORSBypass()">CORS Testing</button>
                <button onclick="testProxyBehavior()">Proxy Analysis</button>
                <button onclick="testSSLCertificates()">SSL Certificate Info</button>
                <div id="advanced-output" class="output"></div>
            </div>

            <!-- Data Exfiltration Testing -->
            <div class="section critical">
                <h2>üì° Data Exfiltration Testing</h2>
                <button onclick="testDataUpload()">Upload Testing</button>
                <button onclick="testDataDownload()">Download Testing</button>
                <button onclick="testDNSExfiltration()">DNS Exfiltration</button>
                <button class="critical-btn" onclick="establishBeacon()">Establish Beacon</button>
                <div id="exfiltration-output" class="output"></div>
            </div>

            <!-- Link Generation -->
            <div class="section success">
                <h2>üîó Dynamic Link Generation</h2>
                <button onclick="generateDirectLinks()">Generate Direct Links</button>
                <button onclick="generateCommonPaths()">Common Paths</button>
                <button onclick="generateAdminLinks()">Admin Links</button>
                <button onclick="generateAPILinks()">API Links</button>
                <div id="links-output" class="output"></div>
            </div>
        </div>

        <!-- Results Summary -->
        <div class="section success">
            <h2>üìä Comprehensive Results</h2>
            <button onclick="generateReport()">Generate Report</button>
            <button onclick="exportFindings()">Export Findings</button>
            <button onclick="clearAllResults()">Clear Results</button>
            <div id="results-output" class="output"></div>
        </div>
    </div>

    <script>
        let targets = [];
        let testResults = {};
        let totalTests = 0;
        let completedTests = 0;

        function log(section, message, type = 'info') {
            const output = document.getElementById(section + '-output');
            const timestamp = new Date().toLocaleTimeString();
            const indicator = type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : type === 'critical' ? 'üö®' : '‚ÑπÔ∏è';
            
            output.innerHTML += `<span class="${type}">[${timestamp}] ${indicator} ${message}</span>\n`;
            output.scrollTop = output.scrollHeight;
            
            // Store results
            if (!testResults[section]) testResults[section] = [];
            testResults[section].push({timestamp, message, type, target: getCurrentTarget()});
        }

        function getCurrentTarget() {
            return window.currentTarget || 'general';
        }

        function updateStats() {
            document.getElementById('total-targets').textContent = targets.length;
            document.getElementById('tests-run').textContent = completedTests;
            
            const accessible = targets.filter(t => t.status === 'accessible').length;
            document.getElementById('accessible-targets').textContent = accessible;
            
            const successRate = totalTests > 0 ? Math.round((accessible / targets.length) * 100) : 0;
            document.getElementById('success-rate').textContent = successRate + '%';
        }

        function updateProgress() {
            if (totalTests > 0) {
                const progress = (completedTests / totalTests) * 100;
                document.getElementById('progress-fill').style.width = progress + '%';
            }
        }

        // Target Management Functions
        function addSingleTarget() {
            const target = document.getElementById('single-target').value.trim();
            if (target && !targets.find(t => t.url === target)) {
                targets.push({
                    url: target,
                    status: 'unknown',
                    results: {},
                    addedAt: new Date().toISOString()
                });
                document.getElementById('single-target').value = '';
                updateTargetList();
                updateStats();
                log('results', `Target added: ${target}`, 'success');
            }
        }

        function addCommonPorts() {
            const baseTarget = document.getElementById('single-target').value.trim();
            if (!baseTarget) return;
            
            const commonPorts = [80, 443, 8080, 8443, 9000, 3000, 5000, 8000, 8081, 9090];
            const host = baseTarget.split(':')[0];
            
            commonPorts.forEach(port => {
                const target = `${host}:${port}`;
                if (!targets.find(t => t.url === target)) {
                    targets.push({
                        url: target,
                        status: 'unknown',
                        results: {},
                        addedAt: new Date().toISOString()
                    });
                }
            });
            
            document.getElementById('single-target').value = '';
            updateTargetList();
            updateStats();
            log('results', `Added ${commonPorts.length} port variants for ${host}`, 'success');
        }

        function addBulkTargets() {
            const bulkText = document.getElementById('bulk-targets').value;
            const newTargets = bulkText.split('\n')
                .map(t => t.trim())
                .filter(t => t && !targets.find(existing => existing.url === t));
            
            newTargets.forEach(target => {
                targets.push({
                    url: target,
                    status: 'unknown',
                    results: {},
                    addedAt: new Date().toISOString()
                });
            });
            
            document.getElementById('bulk-targets').value = '';
            updateTargetList();
            updateStats();
            log('results', `Added ${newTargets.length} bulk targets`, 'success');
        }

        function generateRangeTargets() {
            const range = document.getElementById('ip-range').value.trim();
            const ports = document.getElementById('port-list').value.trim();
            
            if (!range) return;
            
            const portList = ports ? ports.split(',').map(p => p.trim()) : [''];
            const [baseIP, rangeEnd] = range.split('-');
            
            if (!baseIP || !rangeEnd) {
                log('results', 'Invalid IP range format. Use: 192.168.1.1-254', 'error');
                return;
            }
            
            const ipParts = baseIP.split('.');
            if (ipParts.length !== 4) {
                log('results', 'Invalid IP format', 'error');
                return;
            }
            
            const baseNetwork = ipParts.slice(0, 3).join('.');
            const startHost = parseInt(ipParts[3]);
            const endHost = parseInt(rangeEnd);
            
            let addedCount = 0;
            for (let host = startHost; host <= endHost; host++) {
                const ip = `${baseNetwork}.${host}`;
                
                portList.forEach(port => {
                    const target = port ? `${ip}:${port}` : ip;
                    if (!targets.find(t => t.url === target)) {
                        targets.push({
                            url: target,
                            status: 'unknown',
                            results: {},
                            addedAt: new Date().toISOString()
                        });
                        addedCount++;
                    }
                });
            }
            
            updateTargetList();
            updateStats();
            log('results', `Generated ${addedCount} targets from IP range`, 'success');
        }

        function updateTargetList() {
            const listContainer = document.getElementById('target-list');
            listContainer.innerHTML = '';
            
            targets.forEach((target, index) => {
                const item = document.createElement('div');
                item.className = 'target-item';
                
                const statusClass = target.status === 'accessible' ? 'status-success' : 
                                  target.status === 'blocked' ? 'status-error' : 
                                  target.status === 'partial' ? 'status-warning' : 'status-unknown';
                
                item.innerHTML = `
                    <div>
                        <span class="status-indicator ${statusClass}"></span>
                        <strong>${target.url}</strong>
                        <small style="color: #888; margin-left: 10px;">${target.status}</small>
                    </div>
                    <div class="target-links">
                        <a href="http://${target.url}" target="_blank">HTTP</a>
                        <a href="https://${target.url}" target="_blank">HTTPS</a>
                        <button onclick="testSingleTarget(${index})" style="font-size: 10px; padding: 2px 6px;">Test</button>
                        <button onclick="removeTarget(${index})" style="font-size: 10px; padding: 2px 6px; background: #5a1a1a;">Remove</button>
                    </div>
                `;
                
                listContainer.appendChild(item);
            });
        }

        function removeTarget(index) {
            targets.splice(index, 1);
            updateTargetList();
            updateStats();
        }

        function clearAllTargets() {
            targets = [];
            testResults = {};
            updateTargetList();
            updateStats();
            log('results', 'All targets cleared', 'warning');
        }

        // Testing Functions
        async function testBasicConnectivity() {
            log('connectivity', 'Starting basic connectivity tests...', 'info');
            
            for (const target of targets) {
                window.currentTarget = target.url;
                
                try {
                    // Test basic HTTP connectivity
                    const startTime = Date.now();
                    const response = await fetch(`http://${target.url}`, {
                        method: 'HEAD',
                        mode: 'no-cors',
                        signal: AbortSignal.timeout(5000)
                    });
                    const responseTime = Date.now() - startTime;
                    
                    target.results.connectivity = {
                        accessible: true,
                        responseTime: responseTime,
                        method: 'HTTP'
                    };
                    
                    if (target.status === 'unknown') target.status = 'accessible';
                    log('connectivity', `‚úÖ ${target.url} - Accessible (${responseTime}ms)`, 'success');
                    
                } catch (error) {
                    // Try HTTPS
                    try {
                        const startTime = Date.now();
                        const response = await fetch(`https://${target.url}`, {
                            method: 'HEAD',
                            mode: 'no-cors',
                            signal: AbortSignal.timeout(5000)
                        });
                        const responseTime = Date.now() - startTime;
                        
                        target.results.connectivity = {
                            accessible: true,
                            responseTime: responseTime,
                            method: 'HTTPS'
                        };
                        
                        if (target.status === 'unknown') target.status = 'accessible';
                        log('connectivity', `‚úÖ ${target.url} - Accessible via HTTPS (${responseTime}ms)`, 'success');
                        
                    } catch (httpsError) {
                        target.results.connectivity = {
                            accessible: false,
                            error: error.message
                        };
                        
                        if (target.status === 'unknown') target.status = 'blocked';
                        log('connectivity', `‚ùå ${target.url} - Not accessible: ${error.message}`, 'error');
                    }
                }
                
                completedTests++;
                updateProgress();
                await new Promise(resolve => setTimeout(resolve, 100)); // Rate limiting
            }
            
            updateTargetList();
            updateStats();
            log('connectivity', 'Basic connectivity tests completed', 'success');
        }

        async function testHTTPAccess() {
            log('http', 'Testing HTTP access methods...', 'info');
            
            for (const target of targets) {
                if (target.status === 'blocked') continue;
                
                window.currentTarget = target.url;
                
                try {
                    // Test different HTTP methods
                    const methods = ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'HEAD'];
                    const results = {};
                    
                    for (const method of methods) {
                        try {
                            const response = await fetch(`http://${target.url}`, {
                                method: method,
                                mode: 'cors',
                                signal: AbortSignal.timeout(3000)
                            });
                            
                            results[method] = {
                                status: response.status,
                                accessible: true
                            };
                            
                            log('http', `‚úÖ ${target.url} - ${method} (${response.status})`, 'success');
                            
                        } catch (error) {
                            results[method] = {
                                accessible: false,
                                error: error.message
                            };
                        }
                    }
                    
                    target.results.httpMethods = results;
                    
                } catch (error) {
                    log('http', `‚ùå ${target.url} - HTTP test failed: ${error.message}`, 'error');
                }
                
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            log('http', 'HTTP access testing completed', 'success');
        }

        async function testHTTPSAccess() {
            log('http', 'Testing HTTPS access...', 'info');
            
            for (const target of targets) {
                if (target.status === 'blocked') continue;
                
                window.currentTarget = target.url;
                
                try {
                    const response = await fetch(`https://${target.url}`, {
                        method: 'GET',
                        mode: 'cors',
                        signal: AbortSignal.timeout(5000)
                    });
                    
                    target.results.https = {
                        accessible: true,
                        status: response.status,
                        headers: Object.fromEntries(response.headers.entries())
                    };
                    
                    log('http', `‚úÖ ${target.url} - HTTPS accessible (${response.status})`, 'success');
                    
                } catch (error) {
                    target.results.https = {
                        accessible: false,
                        error: error.message
                    };
                    
                    log('http', `‚ùå ${target.url} - HTTPS failed: ${error.message}`, 'error');
                }
                
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            log('http', 'HTTPS access testing completed', 'success');
        }

        async function discoverServices() {
            log('discovery', 'Starting service discovery...', 'info');
            
            const commonPaths = [
                '/', '/admin', '/api', '/login', '/dashboard', '/status', '/health',
                '/robots.txt', '/sitemap.xml', '/.well-known/', '/favicon.ico',
                '/wp-admin', '/phpmyadmin', '/admin.php', '/administrator',
                '/api/v1', '/api/v2', '/rest', '/graphql', '/swagger',
                '/management', '/actuator', '/metrics', '/debug'
            ];
            
            for (const target of targets) {
                if (target.status === 'blocked') continue;
                
                window.currentTarget = target.url;
                const discoveredPaths = [];
                
                for (const path of commonPaths) {
                    try {
                        const response = await fetch(`http://${target.url}${path}`, {
                            method: 'HEAD',
                            mode: 'no-cors',
                            signal: AbortSignal.timeout(2000)
                        });
                        
                        discoveredPaths.push({
                            path: path,
                            accessible: true,
                            status: response.status
                        });
                        
                        log('discovery', `‚úÖ ${target.url}${path} - Found`, 'success');
                        
                    } catch (error) {
                        // Path not accessible - normal behavior
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                target.results.discoveredPaths = discoveredPaths;
                
                if (discoveredPaths.length > 0) {
                    log('discovery', `${target.url} - Found ${discoveredPaths.length} accessible paths`, 'success');
                }
            }
            
            log('discovery', 'Service discovery completed', 'success');
        }

        async function testWebSocketConnections() {
            log('advanced', 'Testing WebSocket connections...', 'info');
            
            for (const target of targets) {
                if (target.status === 'blocked') continue;
                
                window.currentTarget = target.url;
                
                try {
                    const ws = new WebSocket(`ws://${target.url}`);
                    
                    ws.onopen = function() {
                        log('advanced', `‚úÖ ${target.url} - WebSocket connection opened`, 'success');
                        target.results.websocket = { accessible: true };
                        ws.close();
                    };
                    
                    ws.onerror = function(error) {
                        log('advanced', `‚ùå ${target.url} - WebSocket connection failed`, 'error');
                        target.results.websocket = { accessible: false };
                    };
                    
                    // Try secure WebSocket
                    setTimeout(() => {
                        try {
                            const wss = new WebSocket(`wss://${target.url}`);
                            wss.onopen = function() {
                                log('advanced', `‚úÖ ${target.url} - Secure WebSocket connection opened`, 'success');
                                target.results.websocketSecure = { accessible: true };
                                wss.close();
                            };
                            wss.onerror = function() {
                                target.results.websocketSecure = { accessible: false };
                            };
                        } catch (e) {
                            // WSS not supported
                        }
                    }, 1000);
                    
                } catch (error) {
                    log('advanced', `‚ùå ${target.url} - WebSocket test failed: ${error.message}`, 'error');
                }
                
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
            
            log('advanced', 'WebSocket testing completed', 'success');
        }

        async function establishBeacon() {
            log('exfiltration', 'Establishing beacon connections...', 'critical');
            
            for (const target of targets) {
                if (target.status !== 'accessible') continue;
                
                window.currentTarget = target.url;
                
                try {
                    // Test HTTP POST beacon
                    const beaconData = {
                        timestamp: Date.now(),
                        source: 'isolation-scanner',
                        target: target.url,
                        userAgent: navigator.userAgent,
                        referrer: document.referrer
                    };
                    
                    const response = await fetch(`http://${target.url}/beacon`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(beaconData),
                        signal: AbortSignal.timeout(3000)
                    });
                    
                    if (response.ok) {
                        log('exfiltration', `üö® ${target.url} - Beacon established successfully`, 'critical');
                        target.results.beacon = { established: true, method: 'HTTP POST' };
                    }
                    
                } catch (error) {
                    // Try GET beacon
                    try {
                        const params = new URLSearchParams({
                            beacon: 'true',
                            timestamp: Date.now(),
                            source: 'isolation-scanner'
                        });
                        
                        await fetch(`http://${target.url}?${params}`, {
                            method: 'GET',
                            mode: 'no-cors',
                            signal: AbortSignal.timeout(3000)
                        });
                        
                        log('exfiltration', `üö® ${target.url} - GET beacon sent`, 'warning');
                        target.results.beacon = { established: true, method: 'HTTP GET' };
                        
                    } catch (getError) {
                        log('exfiltration', `‚ùå ${target.url} - Beacon failed: ${error.message}`, 'error');
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            log('exfiltration', 'Beacon establishment completed', 'success');
        }

        async function generateDirectLinks() {
            log('links', 'Generating direct access links...', 'info');
            
            const linkContainer = document.getElementById('links-output');
            linkContainer.innerHTML += '\nüîó DIRECT ACCESS LINKS:\n';
            
            targets.forEach(target => {
                if (target.status === 'accessible' || target.status === 'partial') {
                    const protocols = ['http', 'https'];
                    const commonPaths = ['/', '/admin', '/api', '/login', '/dashboard'];
                    
                    protocols.forEach(protocol => {
                        commonPaths.forEach(path => {
                            const link = `${protocol}://${target.url}${path}`;
                            linkContainer.innerHTML += `<a href="${link}" target="_blank" style="color: #4dabf7; margin-right: 10px;">${link}</a>\n`;
                        });
                    });
                }
            });
            
            log('links', `Generated direct links for ${targets.filter(t => t.status === 'accessible').length} accessible targets`, 'success');
        }

        async function runAllTests() {
            log('results', 'üöÄ Starting comprehensive testing suite...', 'critical');
            
            totalTests = targets.length * 8; // Approximate number of tests per target
            completedTests = 0;
            updateProgress();
            
            // Run tests in sequence
            await testBasicConnectivity();
            await testHTTPAccess();
            await testHTTPSAccess();
            await discoverServices();
            await testWebSocketConnections();
            await establishBeacon();
            
            generateDirectLinks();
            generateReport();
            
            log('results', '‚úÖ All tests completed!', 'success');
        }

        function generateReport() {
            log('results', 'Generating comprehensive report...', 'info');
            
            const accessibleTargets = targets.filter(t => t.status === 'accessible');
            const blockedTargets = targets.filter(t => t.status === 'blocked');
            const partialTargets = targets.filter(t => t.status === 'partial');
            
            log('results', '', 'info');
            log('results', 'üìä RECONNAISSANCE SUMMARY:', 'success');
            log('results', `Total Targets Tested: ${targets.length}`, 'info');
            log('results', `Accessible Targets: ${accessibleTargets.length}`, 'success');
            log('results', `Blocked Targets: ${blockedTargets.length}`, 'error');
            log('results', `Partial Access: ${partialTargets.length}`, 'warning');
            
            if (accessibleTargets.length > 0) {
                log('results', '', 'info');
                log('results', 'üéØ HIGH-VALUE ACCESSIBLE TARGETS:', 'critical');
                accessibleTargets.forEach(target => {
                    const services = target.results.discoveredPaths ? target.results.discoveredPaths.length : 0;
                    const methods = target.results.httpMethods ? Object.keys(target.results.httpMethods).filter(m => target.results.httpMethods[m].accessible).length : 0;
                    log('results', `  ${target.url} - ${services} services, ${methods} HTTP methods`, 'critical');
                });
            }
            
            log('results', '', 'info');
            log('results', 'üîó Quick Access Links Generated', 'success');
            log('results', 'üì° Beacon Tests Completed', 'success');
            log('results', 'üïµÔ∏è Service Discovery Finished', 'success');
            
            updateStats();
        }

        function exportFindings() {
            const exportData = {
                timestamp: new Date().toISOString(),
                summary: {
                    totalTargets: targets.length,
                    accessibleTargets: targets.filter(t => t.status === 'accessible').length,
                    blockedTargets: targets.filter(t => t.status === 'blocked').length
                },
                targets: targets,
                testResults: testResults
            };
            
            const jsonData = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonData], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `network_reconnaissance_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log('results', 'üìÅ Findings exported successfully', 'success');
        }

        function clearAllResults() {
            const outputs = document.querySelectorAll('.output');
            outputs.forEach(output => output.innerHTML = '');
            testResults = {};
            completedTests = 0;
            totalTests = 0;
            updateProgress();
            updateStats();
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            log('results', 'üïµÔ∏è Internal Network Reconnaissance Tool loaded', 'success');
            log('results', 'Add targets and run comprehensive tests to discover accessible internal services', 'info');
            updateStats();
        });
    </script>
</body>
</html>
